



修改帐号和密码的有效期限:
   
      配置文件：/etc/login.defs

       cat /etc/login.defs
           PASS_MAX_DAYS    99999                        //密码最长有效期
           PASS_MIN_DAYS    0                            //密码最短有效期
           PASS_MIN_LEN    5                             //密码最短长度
           PASS_WARN_AGE    7                            //密码过期前几天提示警告信息
           UID_MIN                  1000                 //UID最小值
           UID_MAX                  60000                //UID最大值
                
            /etc/default/useradd 

           GROUP = 100                                   表示 用户组ID 
           HOME = /HOME                                  表示 家目录的位置
           INACTIVE = -1                                 表示 是否启用帐号过期停权，-1表示不启用。
           EXPIRE=                                       表示 账号是否启用过期设置    无表示不启用
           SHELL = /bin/bash                             表示 账号使用shell种类 
           SKEL = /etc/skel　                            表示 账号家目录使用默认的内容　　　　              
           CREATE_MAIL_SPOOL=yes                         表示 是否创建邮箱缓存  yes表示创建

                （注）通过修改配置文件，能对之后新建用户起作用，而目前系统已经存在的用户，则直接用chage来配置。
      相关命令：

         chage： 修改帐号和密码的有效期限。
              
             语法

         chage [选项] 用户名
                      选项

                -m：密码可更改的最小天数。为零时代表任何时候都可以更改密码。
                -M：密码保持有效的最大天数。
                -w：用户密码到期前，提前收到警告信息的天数。
                -E：帐号到期的日期。过了这天，此帐号将不可用。
                -d：上一次更改的日期。
                -i：停滞时期。如果一个密码已过期这些天，那么此帐号将不可用。
                -l：例出当前的设置。由非特权用户来确定他们的密码或帐号何时过期。

修改查看用户的认证信息：

          
      配置文件：
            存放用户信息：
            /etc/passwd

                例如：jack:X:503:504:::/home/jack/:/bin/bash
                jack　　                         //用户名
                X　　                            //口令、密码
                       503　　                                 //用户id
                       504　　                                 //所在组
                       :　　                                    //描述
                /home/jack/　　                  //用户主目录
                /bin/bash　　                    //用户缺省Shell

            /etc/shadow
                      
                例如：jack:$!$:???:13801:0:99999:7:*:*:
                jack　　                         //组名
                       $!$　　                                 //被加密的口令
                       13801　　                               //创建日期与今天相隔的天数
                       0　　                                   //口令最短位数
                       99999　　                              //用户口令
                       7　　                                   //到7天时提醒
                       *　　                                   //禁用天数
                       *　　                                   //过期天数

            存放组信息：

            /etc/group
            /etc/gshadow

            相关命令：

                passwd:命令用于设置用户的认证信息，包括用户密码、密码过期时间等。
                               系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。

                      语法

                passwd(选项)(参数)
                               选项

                       -d：删除密码，仅有系统管理者才能使用；
                       -f：强制执行；
                       -k：设置只有在密码过期失效后，方能更新；
                       -l：锁住密码；
                       -s：列出密码的相关信息，仅有系统管理者才能使用；
                       -u：解开已上锁的帐号。

                                参数

                                用户名：需要设置密码的用户名。


修改查看文件属性：
            
            相关命令：

                chattr：用来改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，
                   
                lsattr: 用来查看文件属性。

                  Usage: chattr [-RVf] [-+=aAcCdDeijsStTu] [-v version] files...
                         
                         选项:

                    -R：递归处理，将指令目录下的所有文件及子目录一并处理；
                    -v<版本编号>：设置文件或目录版本；
                    -V：显示指令执行过程；
                            +<属性>：开启文件或目录的该项属性；
                            -<属性>：关闭文件或目录的该项属性；
                            =<属性>：指定文件或目录的该项属性。
                       
                         这些属性共有以下8种模式：

                    a：让文件或目录仅供附加用途；
                    b：不更新文件或目录的最后存取时间；
                    c：将文件或目录压缩后存放；
                    d：将文件或目录排除在倾倒操作之外；
                    i：不得任意更动文件或目录；
                    s：保密性删除文件或目录；
                    S：即时更新文件或目录；
                    u：预防意外删除。

                         实例

                            用chattr命令防止系统中某个关键文件被修改：

                     chattr +i /etc/fstab
                            
                            然后试一下rm、mv、rename等命令操作于该文件，都是得到Operation not permitted的结果。

                            让某个文件只能往里面追加内容，不能删除，一些日志文件适用于这种操作：

                     chattr +a /data1/user_act.log




挂载命令mount:



                    在linux里面所有的可存储设备都需要挂载后才可以正常使用，不过硬盘是系统自动挂载.
                    但是u盘，光盘，移动硬盘等就需要我们手动进行挂载了。相当于为设备分配一个盘符。

                   一、查询与自动挂载
                          1、挂载查询
                      mount -l , cat /proc/mounts
                             查询系统中已经挂载的设备，-l会显示卷标名称。与不加-l效果一样。

                         2、自动挂载
                      mount -a
                             依据配置文件/etc/fstab的内容，自动挂载
                             需要注意的是光盘和u盘或移动硬盘都不要设置为自动挂载，因为一旦光驱里没有光盘媒体或移动设备出问题就会导致系统检测失败而崩溃。

                   二、挂载命令的格式
                      mount [-t 文件系统][-L 卷标名] \
                            [-o 特殊选项] 设备文件名 挂载点

                              选项：
                             -t 文件系统：加入文件系统类型来指定挂载的类型，硬盘的文件系统为ext3、ext4。光盘设备的文件系统类型为iso9660。

                             -L 卷标名： 挂载指定卷标的分区，而不是按照设备文件名挂载。

                             -o 特殊选项：可以指定挂载的额外选项。

                       这个命令看起来挺复杂，但其实我们平时用的时候一般不用加选项，直接用mount+设备文件名+挂载点即可，比如我们前面学习的挂载光驱：
                       mount /dev/sr0 /mnt/cdrom
                                       也就是说如果不加选项的话就代表选项为默认。

                       1、这里特别说明一下-o特殊选项，这个额外选项有好多参数：

                       atime/noatime 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新。

                       async/sync : 异步/同步，默认为异步

                       auto/noauto :自动/手动，mount -a命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动。

                       defaults: 定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这七个选项。

                       exec/noexec:执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是exec允许

                       remount ：重新挂载已经挂载的文件系统，一般用于指定修改特殊权限

                       rw/ro：读写/只读，文件系统挂载时，是否具有读写权限，默认为rw

                       suid/nosuid: 具有/不具有suid权限，设定文件系统是否具有suid和sgid的权限，默认是具有

                       user/nouser :允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有root可以挂载分区

                       usrquota :写入代表文件系统支持用户磁盘配额，默认不支持

                       grpquota : 写入代表文件系统支持组磁盘配额，默认不支持。

                        2、这里我们比较常用的就是从新挂载参数remount，以及exec/noexec.

                           比如我们修改了挂载分区文件系统的一些参数，而不想从新启动系统，这时候就只需要从新挂载一下这个分区就可以了，命令写法：
                  
                       mount -o remount /home
                         
                               这样就从新挂载了/home分区了。

                 3、exec一般主要用于服务器系统中用户上传文件的目录分区设置为不允许执行可执行的文件，避免用户上传了木马病毒执行后影响了整个系统。
                            用法比如：
                    
                       mount -o remount,noexec /home
                        
                            这样就禁止了home分区里的可执行文件的执行能力。remount,noexec两个参数中间用逗号隔开，也就是添加多个参数的话中间用逗号隔开。

                         而正常情况下不建议大家修改这些分区系统默认选项。

                         那么其实有的时候我们某个可执行文件不能执行并不一定是权限的问题，可能就是这个分区被禁用了执行文件的执行。
                    
                         这就是exec和noexec的作用，正常操作服务器的时候，我们就可以把普通用户用于上传的目录设置为禁止执行，这样就维护了服务器的安全。





切换用户 su ，sudo 权限赋予：

   
              su：命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。
                      
                  语法

              su [选项] [-] [USER [参数]...]
                    
                      选项
。
                 -c<指令>或--command=<指令>：执行完指定的指令后，即恢复原来的身份；
 
                 -f或——fast：适用于csh与tsch，使shell不用去读取启动文件；

                 -l或——login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量； 使 shell 成为登录 shell
                        将有效用户 id 和组 id 更改为 USER 的 id。
                       单个 - 视为 -l。如果未指定 USER，将假定为 root

                 -m,-p或--preserve-environment：变更身份时，不要变更环境变量；

                 -s<shell>或--shell=<shell>：指定要执行的shell；

                 --help：显示帮助；
                 --version；显示版本信息。

                               参数

                               用户：指定要切换身份的目标用户。


                       实例

                           变更帐号为root并在执行ls指令后退出变回原使用者：

                     su -c ls root
                           变更帐号为root并传入-f选项给新执行的shell：

                     su root -f
                           变更帐号为test并改变工作目录至test的家目录：

                     su -test
                           扩展阅读二:su和sudo的区别







                sudo

                sudo:命令用来以其他身份来执行命令，预设的身份为root。
                     
                     配置文件：/etc/sudoers
      
                             在/etc/sudoers中设置了可执行sudo指令的用户。

                             若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码。

                             之后有5分钟的有效期限，超过期限则必须重新输入密码。只有root才可以修改它

                     语法

                sudo(选项)(参数)
                        
                           选项

                     -b：在后台执行指令；
                     -h：显示帮助；
                     -H：将HOME环境变量设为新身份的HOME环境变量；
                     -k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
                     -l：列出目前用户可执行与无法执行的指令；
                     -p：改变询问密码的提示符号；
                     -s<shell>：执行指定的shell；
                     -u<用户>：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
                     -v：延长密码有效期限5分钟；
                     -V ：显示版本信息。

                           参数

                           指令：需要运行的指令和对应的参数。

                          

                     visudo: 能够防止两个用户同时修改它;能进行有限的语法检查。

                     visudo默认的是在vi里打开配置文件，用vi来修改文件。我们可以在编译时修改这个默认项。
                    
                     visudo不会擅自保存带有语法错误的配置文件，它会提示你出现的问题，并询问该如何处理：

                     >>> sudoers file: syntax error, line 22 << 
                           键入“e”是重新编辑，键入“x”是不保存退出，键入“Q”是退出并保存。如果真选择Q，那么sudo将不会再运行，直到错误被纠正。

   
                        实例：
                            让用户Foobar可以通过sudo执行所有root可执行的命令。

                      foobar ALL=(ALL)    ALL
                             保存退出后，切换到foobar用户，我们用它的身份执行命令：

                      ls /root
                      ls: /root: 权限不够

                      sudo ls /root
                      PassWord:
                      anaconda-ks.cfg Desktop install.log install.log.syslog

                            第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明foobar可以在此主机上执行后面的命令。

                            第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。

                            最后一个ALL当然就是指命令名了。例如，我们想让foobar用户在linux主机上以jimmy或rene的身份执行kill命令，这样编写配置文件：

                      foobar    linux=(jimmy,rene)    /bin/kil
                      foobar可以使用sudo -u jimmy kill PID
                                   sudo -u rene kill PID，

                            把rene或jimmy设为默认的目标用户即可。再在上面加一行：

                      Defaults:foobar    runas_default=rene
                      Defaults后面如果有冒号，是对后面用户的默认，如果没有，则是对所有用户的默认。就像配置文件中自带的一行：

                      Defaults    env_reset

                            不再输入密码

                      foobar localhost=NOPASSWD:     /bin/cat, /bin/ls

    
                           “某些命令用户foobar不可以运行”，通过使用!操作符，但这不是一个好主意。
                             因为，用!操作符来从ALL中“剔出”一些命令一般是没什么效果的，一个用户完全可以把那个命令拷贝到别的地方，换一个名字后再来运行。

                       日志与安全： 

                     sudo为安全考虑得很周到，不仅可以记录日志，还能在有必要时向系统管理员报告。
 
                           但是，sudo的日志功能不是自动的，必须由管理员开启。这样来做：

 
                      1.touch /var/log/sudo
                                        
                            2.修改/etc/sudoers配置，添加日志设置

                      # visudo
                        Defaults  logfile="/var/log/sudo"
                      
                           这样，sudo就可以写日志了


                           重定向没有被记录在案！为什么？因为在命令运行之前，shell把重定向的工作做完了，sudo根本就没看到重定向。这也有个好处，下面的手段不会得逞：

                        sudo ls /root > /etc/shadowbash: /etc/shadow: 权限不够
                        sudo 有自己的方式来保护安全。以root的身份执行sudo-V，查看一下sudo的设置。因为考虑到安全问题，
                               一部分环境变量并没有传递给sudo后面的命令，或者被检查后再传递的，
                               比如：PATH，HOME，SHELL等。当然，你也可以通过sudoers来配置这些环境变量



                           由于su 对切换到超级权限用户root后，权限的无限制性，所以su并不能担任多个管理员所管理的系统。如果用su 来切换到超级用户来管理系统，也不能明确哪些工作是由哪个管理员进行的操作。特别是对于服务器的管理有多人参与管理时，最好是针对每个管理员的技术特长和 管理范围，并且有针对性的下放给权限，并且约定其使用哪些工具来完成与其相关的工作，这时我们就有必要用到 sudo。

                          通过sudo，我们能把某些超级权限有针对性的下放，并且不需要普通用户知道root密码，所以sudo 相对于权限无限制性的su来说，还是比较安全的，所以sudo 也能被称为受限制的su ；另外sudo 是需要授权许可的，所以也被称为授权许可的su；
 
                    sudo 执行命令的流程是当前用户切换到root（或其它指定切换到的用户），然后以root（或其它指定的切换到的用户）身份执行命令，执行完成后，直接退回到当前用户；而这些的前提是要通过sudo的配置文件/etc/sudoers来进行授权；





提高SSH服务安全：


              ssh:Secure Shell（安全外壳协议）
              SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。
  
                  配置文件：/etc/ssh/sshd_config
                  
                     
              vim /etc/ssh/sshd_config

              Protocol 2                             //SSH协议
              PermitRootLogin no                     //禁止root用户登录
              PermitEmptyPasswords no                //禁止密码为空的用户登录
              UseDNS  no                             //不解析客户机地址
              LoginGraceTime  1m                     //登录限时
              MaxAuthTries  3                        //每连接最多认证次数


                  针对SSH访问采用仅允许的策略，未明确列出的用户一概拒绝登录(白名单，黑名单)

                 AllowUsers zhangsan tom useradm@192.168.4.0/24   //定义账户白名单
                 ##DenyUsers  USER1  USER2                        //定义账户黑名单
                 ##DenyGroups  GROUP1 GROUP2                      //定义组黑名单
                 ##AllowGroups  GROUP1 GROUP2                     //定义组白名单
                 
                 
                 
                 实现密钥对验证登录（私钥口令）、免密码登入
                 
                 
                 ssh-keygen
                 
                 ssh-copy-id root@192.168.4.5   or
                 
                 scp /etc/.ssh/id_rsa.pub  root@192.168.4.5:/authorized_keys
                 
                 
                 vim /etc/ssh/sshd_config
                 .. ..
                 PasswordAuthentication no                              //将此行yes改成no
                 
                 
                 
                 
MD5


              MD5:报文摘要算法（Message-DigestAlgorithm 5）
                       
                       用于检查文件完整性,产生一个二进制长度128位（十六进制长度32位）的校验和
           





                   命令格式
          
                     md5sum [OPTION]... [FILE]...
                     
                      
                     
                   命令选项
                     
                     -b或 --binary:以二进制模式读入文件；
                     
                     -t或 --text:以文本文件模式读入文件（默认）；
                     
                     -c或 --check:用来从文件中读取md5信息检查文件的一致性；
                     
                     --status:该选项与check一起使用，在check时不输出，根据返回值表示检查结果；
                     
                     -w或 --warn:在check时，检查输入的md5信息有没有非法行，若有则输出相应信息。
          


                    实例
 
                      md5sum aaa* > checksum/aaa_all.md5

                      文件内容校验
 
                      md5sum -c ./checksum/all.md5





                    总结
                      
                      特殊说明
                      
                      1）md5sum是校验文件内容，与文件名是否相同无关；
                      
                      2）md5sum是逐位校验，所以文件越大，校验时间越长。
                      
                       
                      
                      md5校验，可能极小概率出现不同的文件生成相同的校验和，比md5更安全的校验算法还有SHA*系列，如sha1sum/sha224sum/sha256sum/sha384sum/sha512sum等等，基本用法与md5sum命令类似，详情可通过man sha1sum查询。
                      
                      以下仅简单列举一例
                      
                       sha512sum aaa.txt > aaa.sha512
                      
                       cat aaa.sha512
                      
                      8edb9790359ef641112fa85eea5c8f09b7330564a58cddf39aef66006f32454a8879b1e63d9f667ecf86264d4d5b6a602a4c94c79d962ec755345a3837217f89 aaa.txt
                      
                      
                      
                       sha512sum -c ./aaa.sha512
                      
                       aaa.txt:OK


加密与解密应用:


                  加密算法主要有以下几种分类：

                       1.为确保数据机密性算法：

                         a) 对称加密算法(AES,DES)

                         b) 非对称加密算法（RSA，DSA）

                       2.为确保数据完整性算法：

                         a) 信息摘要（MD5，SHA256，SHA512）



        

           GPG
 
                    软件：GnuPG
                          非常流行的加密软件，支持所有常见加密算法，并且开源免费使用

             用GPG对称加密方式保护文件:
                     
                          gpg使用对称加密算法加密数据的操作

                          执行下列操作：

                          gpg -c file2.txt
                          .. ..                                  //根据提示依次输入两次密码即可
                          
                          cat file2.txt.gpg                      //查看加密数据为乱码
                          
                          使用gpg对加密文件进行解密操作

                          收到加密的文件后，必须进行解密才能查看其内容。

                          gpg -d file2.txt.gpg > file2.txt       //解密后保存

                          gpg: 3DES 加密过的数据

                          .. ..                                  //根据提示输入正确密码
                          cat file2.txt                          //查看解密后的文件

                          abcdef
                          123456779




      使用GPG非对称加密方式保护文件

                     1）接收方UserA创建自己的公钥、私钥对(在192.168.4.100操作)
                           gpg --gen-key                                 //创建密钥对
                          … …
                          请选择您要使用的密钥种类：
                             (1) RSA and RSA (default)                   //默认算法为RSA
                             (2) DSA and Elgamal
                             (3) DSA (仅用于签名)
                             (4) RSA (仅用于签名)
                          您的选择？                                     //直接回车默认(1)
                          RSA 密钥长度应在 1024 位与 4096 位之间。
                          您想要用多大的密钥尺寸？(2048)                 //接受默认2048位
                          您所要求的密钥尺寸是 2048 位
                          请设定这把密钥的有效期限。
                                   0 = 密钥永不过期
                                <n>  = 密钥在 n 天后过期
                                <n>w = 密钥在 n 周后过期
                                <n>m = 密钥在 n 月后过期
                                <n>y = 密钥在 n 年后过期
                          密钥的有效期限是？(0)                          //接受默认永不过期
                          密钥永远不会过期
                          以上正确吗？(y/n)y                             //输入y确认
                          You need a user ID to identify your key; the software constructs the user ID
                          from the Real Name, Comment and Email Address in this form:
                              "Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>"
                          真实姓名：UserA
                          电子邮件地址：UserA@tarena.com
                          注释：UserA
                          您选定了这个用户标识：
                              “UserA (UserA) <UserA@tarena.com>”
                          更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？O          //输入大写O确认
                          您需要一个密码来保护您的私钥。
                          我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动
                          鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。
                          gpg: 正在检查信任度数据库
                          gpg: 需要 3 份勉强信任和 1 份完全信任，PGP 信任模型
                          gpg: 深度：0 有效性：  1 已签名：  0 信任度：0-，0q，0n，0m，0f，1u
                          pub   2048R/421C9354 2017-08-16
                          密钥指纹 = 8A27 6FB5 1315 CEF8 D8A0  A65B F0C9 7DA6 421C 9354
                          uid                  UserA (UserA) <UserA@tarena.com>
                          sub   2048R/9FA3AD25 2017-08-16
                 
                          注意：生产密钥后当前终端可能会变的无法使用，执行reset命令即可，或者关闭后再开一个终端。
                
                    2）UserA导出自己的公钥文件(在192.168.4.100操作)

                          用户的公钥、私钥信息分别保存在pubring.gpg和secring.gpg文件内：
                           gpg --list-keys                          //查看公钥环
                          /root/.gnupg/pubring.gpg
                          ------------------------------
                          pub   2048R/421C9354 2017-08-16
                          uid                  UserA (User A) <UserA@tarena.com>
                          sub   2048R/9FA3AD25 2017-08-16
                          使用gpg命令结合--export选项将其中的公钥文本导出：
                           gpg -a --export UserA > UserA.pub
                          //--export的作用是导出密钥，-a的作用是导出的密钥存储为ASCII格式
                           scp UserA.pub 192.168.4.5:/tmp/ 
                          //将密钥传给Proxy
                   3）UserB导入接收的公钥信息（在192.168.4.5操作）
                          使用gpg命令结合--import选项导入发送方的公钥信息，以便在加密文件时指定对应的公钥。
                          gpg --import /tmp/UserA.pub
                          gpg: 密钥 421C9354：公钥“UserA (UserA) <UserA@tarena.com>”已导入
                          gpg: 合计被处理的数量：1
                          gpg:           已导入：1  (RSA: 1) 
                   4) UserB使用公钥加密数据，并把加密后的数据传给UserA（在192.168.4.5操作）
                          echo "I love you ." > love.txt
                          gpg -e -r UserA love.txt
                          无论如何还是使用这把密钥吗？(y/N)y                          //确认使用此密钥加密文件
                          //-e选项是使用密钥加密数据
                          //-r选项后面跟的是密钥，说明使用哪个密钥对文件加密
                          scp love.txt.gpg  192.168.4.100:/root    //加密的数据传给UserA
                          4）UserA以自己的私钥解密文件（在192.168.4.100操作）
                           gpg -d love.txt.gpg > love.txt
                          您需要输入密码，才能解开这个用户的私钥：“UserA (UserA) <UserA@tarena.com>”
                          2048 位的 RSA 密钥，钥匙号 9FA3AD25，建立于 2017-08-16 (主钥匙号 421C9354)
                                                                            //验证私钥口令
                          gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 9FA3AD25、生成于 2017-08-16
                                “UserA (UserA) <UserA@tarena.com>”
                           cat love.txt                      //获得解密后的文件内容
                          I love you.
步骤四：使用GPG的签名机制，检查数据来源的正确性

使用私钥签名的文件，是可以使用对应的公钥验证签名的，只要验证成功，则说明这个文件一定是出自对应的私钥签名，除非私钥被盗，否则一定能证明这个文件来自于某个人！
1）在client(192.168.4.100)上，UserA为软件包创建分离式签名
将软件包、签名文件、公钥文件一起发布给其他用户下载。
tar zcf log.tar /var/log              //建立测试软件包
gpg -b log.tar                      //创建分离式数字签名
ls -lh log.tar*
-rw-rw-r--. 1 root root 170 8月  17 21:18 log.tar
-rw-rw-r--. 1 root root 287 8月  17 21:22 log.tar.sig
[root@client ~]# scp log.tar* 192.168.4.5:/root        //将签名文件与签名传给UserB
2）在192.168.4.5上验证签名
gpg --verify log.tar.sig log.tar
gpg:于2028年06月07日 星期六 23时23分23秒 CST 创建的签名，使用 RSA，钥匙号 421C9354
gpg: 完好的签名，来自于“UserA (UserA) <UserA@tarena.com>”
.. ..
2 案例2：使用AIDE做入侵检测
2.1 问题

本案例要求熟悉Linux主机环境下的常用安全工具，完成以下任务操作：
安装aide软件
执行初始化校验操作，生成校验数据库文件
备份数据库文件到安全的地方
使用数据库执行入侵检测操作
2.2 方案

Aide通过检查数据文件的权限、时间、大小、哈希值等，校验数据的完整性。
使用Aide需要在数据没有被破坏前，对数据完成初始化校验，生成校验数据库文件，在被攻击后，可以使用数据库文件，快速定位被人篡改的文件。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署AIDE入侵检测系统

1）安装软件包
[root@proxy ~]# yum -y install aide
2) 修改配置文件
确定对哪些数据进行校验，如何校验数据
[root@proxy ~]# vim /etc/aide.conf
@@define DBDIR /var/lib/aide                            //数据库目录
@@define LOGDIR /var/log/aide                            //日志目录
database_out=file:@@{DBDIR}/aide.db.new.gz                //数据库文件名
//一下内容为可以检查的项目（权限，用户，组，大小，哈希值等）
#p:      permissions
#i:      inode:
#n:      number of links
#u:      user
#g:      group
#s:      size
#md5:    md5 checksum
#sha1:   sha1 checksum
#sha256:        sha256 checksum
DATAONLY =  p+n+u+g+s+acl+selinux+xattrs+sha256
//以下内容设置需要对哪些数据进行入侵校验检查
//注意：为了校验的效率，这里将所有默认的校验目录与文件都注释
//仅保留/root目录，其他目录都注释掉
/root   DATAONLY
#/boot   NORMAL                                    //对哪些目录进行什么校验
#/bin    NORMAL
#/sbin   NORMAL
#/lib    NORMAL
#/lib64  NORMAL
#/opt    NORMAL
#/usr    NORMAL
#!/usr/src                                        //使用[!]，设置不校验的目录
#!/usr/tmp
步骤二：初始化数据库，入侵后检测

1）入侵前对数据进行校验，生成初始化数据库
[root@proxy ~]# aide --init
AIDE, version 0.15.1
AIDE database at /var/lib/aide/aide.db.new.gz initialized.
//生成校验数据库，数据保存在/var/lib/aide/aide.db.new.gz
2）备份数据库，将数据库文件拷贝到U盘（非必须的操作）
[root@proxy ~]# cp /var/lib/aide/aide.db.new.gz   /media/
3）入侵后检测
[root@proxy ~]# cd /var/lib/aide/
[root@proxy ~]# mv aide.db.new.gz aide.db.gz
[root@proxy ~]# aide --check                            //检查哪些数据发生了变化
3 案例3：扫描与抓包分析
3.1 问题

本案例要求熟悉Linux主机环境下的常用安全工具，完成以下任务操作：
使用NMAP扫描来获取指定主机/网段的相关信息
使用tcpdump分析FTP访问中的明文交换信息
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用NMAP扫描来获取指定主机/网段的相关信息

1）安装软件
[root@proxy ~]# yum -y install nmap
//基本用法：
# nmap  [扫描类型]  [选项]  <扫描目标 ...>
//常用的扫描类型
// -sS，TCP SYN扫描（半开）
// -sT，TCP 连接扫描（全开）
// -sU，UDP扫描
// -sP，ICMP扫描
// -A，目标系统全面分析
2）检查192.168.4.100主机是否可以ping通
[root@proxy ~]# nmap  -sP  192.168.4.100
Starting Nmap 6.40 ( http://nmap.org ) at 2018-06-06 21:59 CST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for host3 (192.168.4.100)
Host is up (0.00036s latency).
MAC Address: 52:54:00:71:07:76 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.02 seconds
使用-n选项可以不执行DNS解析
[root@proxy ~]# nmap -n -sP  192.168.4.100
Starting Nmap 6.40 ( http://nmap.org ) at 2018-06-06 22:00 CST
Nmap scan report for 192.168.4.100
Host is up (0.00046s latency).
MAC Address: 52:54:00:71:07:76 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.03 seconds
3）检查192.168.4.0/24网段内哪些主机可以ping通
[root@proxy ~]# nmap  -n  -sP  192.168.4.0/24
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:01 CST
Nmap scan report for 192.168.4.1
Host is up.
Nmap scan report for 192.168.4.7
Host is up.
Nmap scan report for 192.168.4.120
Host is up (0.00027s latency).
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap scan report for 192.168.4.110
Host is up (0.00016s latency).
MAC Address: 00:50:56:C0:00:01 (VMware)
Nmap scan report for 192.168.4.120
Host is up (0.00046s latency).
MAC Address: 00:0C:29:DB:84:46 (VMware)
Nmap done: 256 IP addresses (5 hosts up) scanned in 3.57 seconds
4）检查目标主机所开启的TCP服务
[root@proxy ~]# nmap -sT 192.168.4.100
Starting Nmap 5.51 ( http://nmap.org ) at 2018-05-17 17:55 CST
Nmap scan report for 192.168.4.100
Host is up (0.00028s latency).
Not shown: 990 closed ports
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
25/tcp  open  smtp
80/tcp  open  http
110/tcp open  pop3
111/tcp open  rpcbind
143/tcp open  imap
443/tcp open  https
993/tcp open  imaps
995/tcp open  pop3s
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 1.31 seconds
5）检查192.168.4.0/24网段内哪些主机开启了FTP、SSH服务
[root@proxy ~]# nmap -p 21-22 192.168.4.0/24
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:00 CST
Nmap scan report for 192.168.4.1
Host is up (0.000025s latency).
PORT   STATE SERVICE
21/tcp open  ftp
22/tcp open  ssh
Nmap scan report for 192.168.4.7
Host is up.
PORT   STATE    SERVICE
21/tcp filtered ftp
22/tcp filtered ssh
Nmap scan report for 192.168.4.120
Host is up (0.00052s latency).
PORT   STATE SERVICE
21/tcp open  ftp
22/tcp open  ssh
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap scan report for pc110.tarena.com (192.168.4.110)
Host is up (0.00038s latency).
PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp closed ssh
MAC Address: 00:50:56:C0:00:01 (VMware)
Nmap scan report for 192.168.4.120
Host is up (0.00051s latency).
PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp closed ssh
MAC Address: 00:0C:29:DB:84:46 (VMware)
Nmap done: 256 IP addresses (5 hosts up) scanned in 4.88 seconds
6）检查目标主机所开启的UDP服务
[root@proxy ~]# nmap   -sU  192.168.4.100                //指定-sU扫描UDP
53/udp   open          domain
111/udp  open          rpcbind
7）全面分析目标主机192.168.4.100和192.168.4.5的操作系统信息
[root@proxy ~]# nmap -A 192.168.4.100,5
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:03 CST
Nmap scan report for 192.168.4.100                      //主机mail的扫描报告
Host is up (0.0016s latency).
Not shown: 990 closed ports
PORT    STATE SERVICE  VERSION
21/tcp  open  ftp      vsftpd 2.2.2
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| -rw-r--r--    1 0        0            1719 Aug 17 13:33 UserB.pub
| -rw-r--r--    1 0        0             122 Aug 13 05:27 dl.txt
| drwxr-xr-x    2 14       0            4096 Aug 13 09:07 pub
| -rw-rw-r--    1 505      505           170 Aug 17 13:18 tools-1.2.3.tar.gz
|_-rw-rw-r--    1 505      505           287 Aug 17 13:22 tools-1.2.3.tar.gz.sig
22/tcp  open  ssh      OpenSSH 5.3 (protocol 2.0)
| ssh-hostkey: 1024 86:be:d6:89:c1:2d:d9:1f:57:2f:66:d1:af:a8:d3:c6 (DSA)
|_2048 16:0a:15:01:fa:bb:91:1d:cc:ab:68:17:58:f9:49:4f (RSA)
25/tcp  open  smtp     Postfix smtpd
80/tcp  open  http     Apache httpd 2.2.15 ((Red Hat))
|_http-methods: No Allow or Public header in OPTIONS response (status code 302)
| http-title: 302 Found
|_Did not follow redirect to https://192.168.4.100//
110/tcp open  pop3     Dovecot pop3d
|_pop3-capabilities: USER CAPA UIDL TOP OK(K) RESP-CODES PIPELINING STLS SASL(PLAIN)
111/tcp open  rpcbind
MAC Address: 00:0C:29:74:BE:21 (VMware)
No exact OS matches for host (If you know what OS is running on it, see http://nmap.org/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=5.51%D=8/19%OT=21%CT=1%CU=34804%PV=Y%DS=1%DC=D%G=Y%M=000C29%TM=52
OS:11ED90%P=x86_64-redhat-linux-gnu)SEQ(SP=106%GCD=1%ISR=10B%TI=Z%CI=Z%II=I
OS:%TS=A)OPS(O1=M5B4ST11NW6%O2=M5B4ST11NW6%O3=M5B4NNT11NW6%O4=M5B4ST11NW6%O
OS:5=M5B4ST11NW6%O6=M5B4ST11)WIN(W1=3890%W2=3890%W3=3890%W4=3890%W5=3890%W6
OS:=3890)ECN(R=Y%DF=Y%T=40%W=3908%O=M5B4NNSNW6%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O
OS:%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=
OS:0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%
OS:S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(
OS:R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=
OS:N%T=40%CD=S)
Network Distance: 1 hop
Service Info: Host:  mail.tarena.com; OS: Unix
TRACEROUTE
HOP RTT     ADDRESS
1   1.55 ms 192.168.4.100
步骤二：使用tcpdump分析FTP访问中的明文交换信息

1）准备Vsftpd服务器（192.168.4.5操作）
[root@proxy ~]# yum -y install vsftpd
[root@proxy ~]# systemctl restart vsftpd
2）启用tcpdump命令行抓包
执行tcpdump命令行，添加适当的过滤条件，只抓取访问主机192.168.4.5的21端口的数据通信 ，并转换为ASCII码格式的易读文本。
这里假设，192.168.4.5主机有vsftpd服务，如果没有需要提前安装并启动服务！！！
[root@proxy ~]# tcpdump -A host 192.168.4.5 and tcp port 21
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
.. ..                                            //进入等待捕获数据包的状态
//监控选项如下：
// -i，指定监控的网络接口（默认监听第一个网卡）
// -A，转换为 ACSII 码，以方便阅读
// -w，将数据包信息保存到指定文件
// -r，从指定文件读取数据包信息
//tcpdump的过滤条件：
// 类型：host、net、port、portrange
// 方向：src、dst
// 协议：tcp、udp、ip、wlan、arp、……
// 多个条件组合：and、or、not
3）执行FTP访问，并观察tcpdump抓包结果
从192.168.4.100访问主机192.168.4.5的vsftpd服务。
[root@client ~]# yum -y install ftp
[root@client ~]# ftp 192.168.4.5
Connected to 192.168.4.200 (192.168.4.200).
220 (vsFTPd 3.0.2)
Name (192.168.4.200:root): tom       //输入用户名
331 Please specify the password.
Password:                              //输入密码
530 Login incorrect.
Login failed.
ftp>quit                               //退出
观察抓包的结果（回到porxy主机观察tcpdump抓包的结果）：
[root@proxy ~]#
... …
18:47:27.960530 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 1:14, ack 21, win 65515, length 13
E..5..@.@......x...d.*..G.\c.1BvP.......USER tom
18:47:29.657364 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 14:27, ack 55, win 65481, length 13
E..5..@.@......x...d.*..G.\p.1B.P.......PASS 123
4)再次使用tcpdump抓包，使用-w选项可以将抓取的数据包另存为文件，方便后期慢慢分析。
[root@proxy ~]# tcpdump  -A  -w  ftp.cap  \
> host 192.168.4.5  and  tcp  port  21                            //抓包并保存
tcpdump命令的-r选项，可以去读之前抓取的历史数据文件
[root@proxy ~]# tcpdump  -A  -r  ftp.cap | egrep  '(USER|PASS)'    //分析数据包
.. ..
E..(..@.@.. ...x...d.*..G.\c.1BbP.............
18:47:25.967592 IP 192.168.4.5.ftp > 192.168.4.100.novation: Flags [P.], seq 1:21, ack 1, win 229, length 20
E..<FJ@.@.jE...d...x...*.1BbG.\cP...V...220 (vsFTPd 2.2.2)
… …
18:47:27.960530 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 1:14, ack 21, win 65515, length 13
E..5..@.@......x...d.*..G.\c.1BvP.......USER mickey
… …
18:47:27.960783 IP 192.168.4.5.ftp > 192.168.4.100.novation: Flags [P.], seq 21:55, ack 14, win 229, length 34
E..JFL@.@.j5...d...x...*.1BvG.\pP...i~..331 Please specify the password.
… …
18:47:29.657364 IP 192.168.4.5.ftp > 192.168.4.100.novation: Flags [P.], seq 14:27, ack 55, win 65481, length 13
E..5..@.@......x...d.*..G.\p.1B.P.......PASS pwd123
… …
18:47:29.702671 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 55:78, ack 27, win 229, length 23
E..?FN@.@.j>...d...x...*.1B.G.\}P.......230 Login successful.
步骤三：扩展知识，使用tcpdump分析Nginx的明文账户认证信息信息

1）在proxy主机(192.168.4.5)准备一台需要用户认证的Nginx服务器
[root@proxy ~]# cd /usr/local/nginx/conf/
[root@proxy ~]# cp nginx.conf.default  nginx.conf      //还原配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
  listen 80;
  server_name localhost;
auth_basic "xx";
auth_basic_user_file "/usr/local/nignx/pass";
… …
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass jerry   //创建账户文件
New password:123                   //输入密码
Re-type new password:123          //确认密码
[root@proxy ~]# nginx -s reload
2）在proxy主机使用tcpdump命令抓包
[root@proxy ~]# tcpdump  -A  host 192.168.4.5  and  tcp  port  80
3)在真实机使用浏览器访问192.168.4.5
[root@pc001 ~]# firefox  http://192.168.4.5         //根据提示输入用户名与密码
4）回到proxy查看抓包的数据结果
[root@proxy ~]# tcpdump -A host 192.168.4.5 and tcp port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
… …
Authorization: Basic dG9tOjEyMzQ1Ng==
… …
5) 查看base64编码内容
[root@proxy ~]# echo "dG9tOjEyMzQ1Ng==" | base64 -d
tom:123456
[root@proxy ~]# echo "tom:123456" | base64 
dG9tOjEyMzQ1Ngo=







                 iptables



iptables从入门到应用


 一、简介

 1.1、是什么？


      echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf

    iptables是隔离主机以及网络的工具，通过自己设定的规则以及处理动作对数据报文进行检测以及处理。 

 1.2、发展史

    防火墙的发展史就是从墙到链再到表的过程，也即是从简单到复杂的过程。为什么规则越来越多，因为互联网越来越不安全了，所有防火墙的的规则也越来越复杂。防火的工具变化如下：

    ipfirewall(墙)-->ipchains（链条）--iptables（表）

    2.0版内核中，包过滤机制是ipfw，管理工具是ipfwadm；

    2.2 版内核中，包过滤机制ipchain，管理工具是ipchains；

    2.4版及以后的内核中，包过滤机制是netfilter，管理工具iptables。

 二、原理

  2.1、组成

    linux的防火墙由netfilter和iptables组成。用户空间的iptables制定防火墙规则，内核空间的netfilter实现防火墙功能。

    netfilter（内核空间）位于Linux内核中的包过滤防火墙功能体系，称为Linux防火墙的“内核态”。

    iptables(用户空间)位于/sbin/iptables，是用来管理防火墙的命令的工具，为防火墙体系提供过滤规则/策略，决定如何过滤或处理到达防火墙主机的数据包，称为Linux防火墙的“用户态”。

 2.2、实现方式

    Linux系统的防火墙功能是由内核实现的，包过滤防火墙工作在TCP/IP的网络层。

 


    用户空间的iptables制定相应的规则策略控制内核空间的netfilter处理相应的数据访问控制。

     iptables有四表五链(其实有五表，是后来加进来的)，四表分别是下图的的raw，mangle,nat，filter表。五链分别是PREROUTING,INPUT,OUTPUT,FORWARD,POSTROUTING链。表有什么用？链又有什么用呢？其实表决定了数据报文处理的方式，而链则决定了数据报文的流经哪些位置。

    你可以从下图看出规则表的优先级：raw-->mangle-->nat-->filter。

            raw           mangle            nat               filter 
 
        PREROUTING链    PREROUTING链    PREROUTING链   第一条规则，第二条规则.... INPUT链
 
          OUTPUT链     POSTROUNTING链   POSTROUTING链       FORWORD链  
        
                          INPUT链         OUTPUT链           OUTPUT链

                          OUTPUT链
                          
                         FORWORD链

    四表的介绍如图（ps：由于现在有五表了，所以我把另一个表也加了进来）。

       filter：       确定是否放行该数据包（包过滤表）
              
       nat：          修改数据包中的源，目标IP地址或端口(地址转换表)
  
       mangle：       为数据包设置标记（包标记表）
 
       raw：          确定是否对该数据包进行状态跟踪（状态跟踪表）

       security：     是否定义强制访问访问控制规则（MAC）



             
       

    五链的介绍如图。

              INPUT链:      处理入站数据包（入站规则）

              OUTPUT链:     处理出站数据包（出站规则）

              FORWARD链:    处理转发数据包，主要是将数据转发到本机的其他网卡设备（转发规则）

              PREROUTING链: 在进行路由选择前处理数据包，判断目标主机（路由前规则）

              POSTROUTING链:在进行路由选择后处理数据包，判断经由那一接口送往下一跳（路由后规则）       




    制作防火墙规则通常有两种基本策略。一是黑名单策略；二是白名单策略。

    黑名单策略指没有被拒绝的流量都可以通过，这种策略下管理员必须针对每一种新出现的攻击，制定新的规则，因此不推荐。

    白名单策略指没有被允许的流量都要拒绝，这种策略比较保守，根据需要，逐渐开放，目前一般都采用白名单策略，推荐。

 2.3、数据包过滤匹配流程

     如图，我们可以分析数据报文进入本机后应用了哪些表规则以及链规则，根据表规则和链规则我们分析数据包的过滤匹配流程。

    比如我们制定一个filter表的规则，filter表决定是否放行数据包通过，那如果通过，则必须经由INPUT链流入数据包，INPUT链是处理入站数据的，如果没问题，继续放行到用户空间，再经由OUTPUT链将数据包流出。

    那如果是nat表的规则，nat表主要实现转发功能，数据包先经由PREROUTING链进行路由选择，选择好路线后再经由FORWARD链转发数据，然后再进行一个路由选择，最后由POSTROUTING链流出数据。

    其他表规则的数据包流程不做介绍，图中介绍的十分详尽。
                                                                                 +
  - 网络A                                                               网络B ___|
 |                         本机应用程序  ——————————>raw,OUTPUT   --|             | 
 |   入站数据流向             +                     mangle,OUTPUT--|             |
 |                            |                     nat,OUTPUT   --|             |
 |   \     <                                        filter,OUTPUT--| 出站数据流量|
 |    \    /               mangle,INPUT-|                  |       +  \      >   |
 |     \  /                filter,INPUT-|                  |           \    /    |
 |      --                    +         +                  |            \  /     | 
 |                            |_                           |             --      |  
 |-  raw,PREROUTING ---|     |  |                          +                     |
 +                     |     |路|       mangle,FROWORD-|    mangle,POSTROUTING-| |  
   mangle,PREROUTING---| ==> |由|  ===>                |->                     | |
                       |     |选|       filter,FORWORD-|    nat ,  POSTROUTING-|-|
      nat,PREROUTING---|     |择|                      +                       +
                       +     |__|
                   ------------------------转发的数据流量------------------>



三、iptables命令

     iptables命令

                制定iptables表规则思路：
 
                基本语法结构
                        
                详细语法

                语法结构解析
   
                保存和载入规则

 3.1、制定iptables表规则思路

    (1)选择一张表(此表决定了数据报文处理的方式）

    (2)选择一条链(此链决定了数据报文的流经哪些位置)

    (3)选择合适的条件(此条件决定了对数据报文做何种条件匹配)

    (4)选择处理数据报文的动作，制定相应的防火墙规则。

 3.2、基本语法结构

   结构：

    iptables [ -t 表名 ] 管理选项 [ 链名 ] [ 条件匹配 ] [ -j 目标动作或跳转 ]

   几个注意事项：

    不指定表名时，默认表示filter表，不指定链名时，默认表示该表内所有链，除非设置规则链的缺省策略，否则需要指定匹配条件。

     组成：

            table     commend                              chain           Parameter&                              target
                                                                                     Xmatch

                                                                                    ! 取反
            filter     -A 追加新规则于指定链的尾部                INPUT             -p 指定规则协议，tcp udp icmp all    -j ACCEPT 允许数据包通过
                       -D 删除规则                                                         -s 指定数据包的源地址，ip hostname       DROP 直接丢弃数据包，不给出任何回应信息 
iptables -t nat        -L 列出规则                                  FORWARD          -d 指定目的地址                                REJECT 拒绝数据包通过，必要时会给数据发送端一个响应信息
                       -F 清空指定的规则链上的规则；                                      --sport匹配报文源端口                         DNAT 目标地址转换
            mangle     -P 制定链表的策略(ACCEPT|DROP|REJECT)   OUTPUT            --dport匹配报文目标端口                      SNAT 源地址转换
                       -I 插入新规则于指定链的指定位置，默认为首部                        --icmp-type 
            raw        -R 替换指定的规则为新的规则                 PREROUTING        -m tcp  
                       -n 数字格式显示主机地址和端口号；                                  -m state   
                                                           POSTROUTING       -m multiport 
                                                                                    -i 输入接口
                                                                                    -o 输出接口 

 3.3、详细语法

  iptables [-t table] {-A|-C|-D} chain rule-specification
  iptables [-t table] -I chain [rulenum] rule-specification
  iptables [-t table] -R chain rulenum rule-specification
  iptables [-t table] -D chain rulenum
  iptables [-t table] -S [chain [rulenum]]
  iptables [-t table] {-F|-L|-Z} [chain [rulenum]] [options...]
  iptables [-t table] -N chain
  iptables [-t table] -X [chain]
  iptables [-t table] -P chain target
  iptables [-t table] -E old-chain-name new-chain-name
    rule-specification = [matches...] [target]
   match = -m matchname [per-match-options]
   target = -j targetname [per-target-options]
 3.4、语法结构解析

  语法结构解析如下。

  注意：本导图是按照iptables语法结构的使用的先后顺序制作的，如果按照此种方式能够很快地帮助我们记忆以及掌握iptables规则的制定。



语法结构解析

   
          表名 ] 管理选项 [ 链名 ] [ 条件匹配 ] [ -j 目标动作或跳转/处理动作 ]


  3.4.1、表

    其实表的介绍，在上面已经介绍了。这里我们可以再来回顾以下五张表的功能。

       filter：       确定是否放行该数据包（包过滤表）
              
       nat：          修改数据包中的源，目标IP地址或端口(地址转换表)
  
       mangle：       为数据包设置标记（包标记表）
 
       raw：          确定是否对该数据包进行状态跟踪（状态跟踪表）

       security：     是否定义强制访问访问控制规则（MAC）

  3.4.2、管理选项

    管理选项分为三大类，分别为：规则的显示，规则链管理以及规则管理。我们可以通过man帮助查看iptables的用法，大多选项用法都见名知意。



     链管理


    -N, --new-chain chain：新建一个自定义的规则链；
    -X, --delete-chain [chain]：删除用户自定义的引用计数为0的空链；
    -F, --flush [chain]：清空指定的规则链上的规则；
    -E, --rename-chain old-chain new-chain：重命名链；
    -Z, --zero [chain [rulenum]]：置零计数器；
      注意：每个规则都有两个计数器
      packets：被本规则所匹配到的所有报文的个数；
      bytes：被本规则所匹配到的所有报文的大小之和；
    -P, --policy chain target 制定链表的策略(ACCEPT|DROP|REJECT)
    规则管理

 


    -A, --append chain rule-specification：追加新规则于指定链的尾部； 
    -I, --insert chain [rulenum] rule-specification：插入新规则于指定链的指定位置，默认为首部；
    -R, --replace chain rulenum rule-specification：替换指定的规则为新的规则；
    -D, --delete chain rulenum：根据规则编号删除规则；
    -D, --delete chain rule-specification：根据规则本身删除规则；
    规则显示      


     -L, --list [chain]：列出规则；
     -v, --verbose：详细信息； 
     -vv 更详细的信息
     -n, --numeric：数字格式显示主机地址和端口号；
     -x, --exact：显示计数器的精确值，而非圆整后的数据；
     --line-numbers：列出规则时，显示其在链上的相应的编号；
     -S, --list-rules [chain]：显示指定链的所有规则；
 3.4.3、链

    五链的功能如图所示。   

              INPUT链:      处理入站数据包（入站规则）

              OUTPUT链:     处理出站数据包（出站规则）

              FORWARD链:    处理转发数据包，主要是将数据转发到本机的其他网卡设备（转发规则）

              PREROUTING链: 在进行路由选择前处理数据包，判断目标主机（路由前规则）

              POSTROUTING链:在进行路由选择后处理数据包，判断经由那一接口送往下一跳（路由后规则）   


 3.4.4、条件匹配

    条件匹配分为基本匹配和扩展匹配，扩展匹配又分为显示匹配和隐式匹配。

    基本匹配的特点是：无需加载扩展模块，匹配规则生效；扩展匹配的特点是：需要加载扩展模块，匹配规则方可生效。

    隐式匹配的特点：使用-p选项指明协议时，无需再同时使用-m选项指明扩展模块以及不需要手动加载扩展模块；  

    显示匹配的特点：必须使用-m选项指明要调用的扩展模块的扩展机制以及需要手动加载扩展模块。

    基本匹配的使用选项及功能


-p 指定规则协议，tcp udp icmp all
-s 指定数据包的源地址，ip hostname
-d 指定目的地址
-i 输入接口
-o 输出接口                                              
! 取反

    隐式匹配的使用选项及功能    

-p tcp
  --sport 匹配报文源端口；可以给出多个端口，但只能是连续的端口范围 
  --dport 匹配报文目标端口；可以给出多个端口，但只能是连续的端口范围
  --tcp-flags mask comp 匹配报文中的tcp协议的标志位
-p udp
  --sport 匹配报文源端口；可以给出多个端口，但只能是连续的端口范围
  --dport 匹配报文目标端口；可以给出多个端口，但只能是连续的端口范围
--icmp-type
  0/0： echo reply 允许其他主机ping
  8/0：echo request 允许ping其他主机


    显式匹配的使用选项及功能

    显式匹配的选项特别多，所以使用思维导图的方式梳理一下。我们可以使用命令：man iptables-extensions查看具体用法。



    1.multiport(多端口)

     开放多个端口。

例子：
        iptables -I INPUT -d 172.16.100.7 -p tcp -m multiport --dports 22,80 -j ACCEPT
        iptables -I OUTPUT -s 172.16.100.7 -p tcp -m multiport --sports 22,80 -j ACCEPT

    2.iprange（ip范围）

     以连续地址块的方式来指明多IP地址匹配条件。


例子：
    iptables -A INPUT -d 172.16.100.7 -p tcp --dport 23 -m iprange --src-range 172.16.100.1-172.16.100.100 -j ACCEPT
    iptables -A OUTPUT -s 172.16.100.7 -p tcp --sport 23 -m iprange --dst-range 172.16.100.1-172.16.100.100 -j ACCEPT

    3.time（时间范围）

     指定时间范围。


 例子：
        iptables -A INPUT -d 172.16.100.7 -p tcp --dport 901 -m time --weekdays Mon,Tus,Wed,Thu,Fri --timestart 08:00:00 --time-stop 18:00:00 -j ACCEPT
        iptables -A OUTPUT -s 172.16.100.7 -p tcp --sport 901 -j ACCEPT


    4.string(字符串)

     对报文中的应用层数据做字符串模式匹配检测(通过算法实现)。


    --algo {bm|kmp}：字符匹配查找时使用算法
    --string "STRING":　要查找的字符串
    --hex-string “HEX-STRING”: 要查找的字符，先编码成16进制格式

    5.connlimit(连接限制)

     根据每个客户端IP作并发连接数量限制。


    --connlimit-upto n  连接数小于等于n时匹配
    --connlimit-above n 连接数大于n时匹配

    6.limit(速率限制)

     报文速率控制。  

    7.state（状态）

     追踪本机上的请求和响应之间的数据报文的状态。状态有五种：INVALID, ESTABLISHED, NEW, RELATED, UNTRACKED.
     
                      NEW                            新连接请求
--state state         ESTABLISHED established        已建立的连接 
                      INVALID invalid                无法识别的连接
                      RELATED related                相关性的连接，当前连接是一个新请求，但附属于某个已存在的连接
                      UNTRACKED untracked            未追踪的连接
                         
 法则： 

        1、对于进入的状态为ESTABLISHED都应该放行；

        2、对于出去的状态为ESTABLISHED都应该放行；

        3、严格检查进入的状态为NEW的连接；

        4、所有状态为INVALIED都应该拒绝；  

 

 3.4.5、处理动作

    处理动作有内置的处理动作和自定义的处理动作。自定义的处理动作用的比较少，因此只介绍内置的处理动作。


ACCEPT:允许数据包通过
 
DROP:直接丢弃数据包，不给出任何回应信息
 
REJECT:拒绝数据包通过，必要时会给数据发送端一个响应信息
 
LOG:在日志文件中记录日志信息，然后将数据包传递给下一条规则
 
QUEUE: 防火墙将数据包移交到用户空间
 
RETURN:防火墙停止执行当前链中的后续Rules，并返回到调用链 
 
REDIRECT:端口重定向  
 
MARK：做防火墙标记
 
DNAT：目标地址转换
 
SNAT：源地址转换   
                                                 
MASQUERADE:地址伪装
 3.5、保存和载入规则

    CentOS6和CentOS7保存和载入的规则稍有差异。

  3.5.1、CentOS 7


     保存：iptables-save   > /PATH/TO/SOME_RULE_FILE   
    重载：iptabls-restore  < /PATH/FROM/SOME_RULE_FILE    
    -n, --noflush：不清除原有规则    
    -t, --test：仅分析生成规则集，但不提交
  3.5.2、CentOS 6

 

     保存规则：service iptables save   #保存规则于/etc/sysconfig/iptables文件，覆盖保存；   
     重载规则：service iptables restart #默认重载/etc/sysconfig/iptables文件中的规则   
     配置文件：/etc/sysconfig/iptables-config
四、iptables的实践应用

    iptables十分重要与网络的安全息息相关，我们理所应当掌握。不过我们大可不必死记硬背，一定结合实际项目，多多练习，效果才会更好。

 4.1、iptables常用规则

    1.放行sshd服务

1
2
 iptables -t filter -A INPUT -s 192.168.0.0/24 -d 192.168.0.1 -p tcp --dport 22 -j ACCEPT
 iptables -t filter -A OUTPUT -s 192.168.0.1  -p tcp --sport 22 -j ACCEPT
  2.放行httpd/nginx服务

1
2
 iptables -I OUTPUT -s 192.168.0.1 -p tcp --sport 80 -j ACCEPT
 iptables -I INPUT -d 192.168.0.1 -p tcp --dport 80 -j ACCEPT
 

 3.放行本机端的流入流出

1
2
3
  iptables -A  INPUT  -s 127.0.0.1 -d 127.0.0.1 -i lo -j ACCEPT
  iptables -A  OUTPUT  -s 127.0.0.1 -d 127.0.0.1 -o lo -j ACCEPT
  #不放行本机的流入与流出，访问本机的httpd服务，网页会出现Error establishing a database connection。
 4.限制ping 192.168.0.1主机的数据包数，平均2/s个，最多不能超过3个

1
iptables -A INPUT -i ens33 -d 192.168.0.1 -p icmp --icmp-type 8 -m limit --limit 2/second --limit-burst 3 -j ACCEPT
 4.2、如何配置iptables

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
a) 1. 删除现有规则
iptables -F
b) 2. 配置默认链策略
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP
c) 3. 允许远程主机进行SSH连接
iptables -A INPUT -i eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -o eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT
d) 4. 允许本地主机进行SSH连接
iptables -A OUTPUT -o eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT -i eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT
e) 5. 允许HTTP请求
iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -o eth0 -p tcp –sport 80 -m state –state ESTABLISHED -j ACCEPT
 4.3、iptables初始化脚本

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
#!/bin/bash
  
echo &quot;Setting firewall . . . . start&quot;
  
#--------RULESET INIT----------#
iptables -F
iptables -X
iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT
#------------------------------#
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -i eth0 -p tcp ! --syn -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
#------------------------------#
#zabbix
iptables -A INPUT -p tcp --destination-port 10050 -j ACCEPT
iptables -A INPUT -p udp --destination-port 10051 -j ACCEPT
iptables -A OUTPUT -p tcp --destination-port 10050 -j ACCEPT
iptables -A OUTPUT -p udp --destination-port 10051 -j ACCEPT
#for web
iptables -A INPUT -p tcp --destination-port 21 -j ACCEPT
iptables -A INPUT -p tcp --destination-port 80 -j ACCEPT
iptables -A OUTPUT -p tcp --destination-port 80 -j ACCEPT
iptables -A OUTPUT -p tcp --destination-port 21 -j ACCEPT
#for mysql
iptables -A INPUT -p tcp --destination-port 3306 -j ACCEPT
iptables -A OUTPUT -p tcp --destination-port 3306 -j ACCEPT
#for mail
iptables -A INPUT -p tcp --destination-port 25 -j ACCEPT
iptables -A OUTPUT -p tcp --destination-port 25 -j ACCEPT
iptables -A OUTPUT -p tcp --destination-port 110 -j ACCEPT
#for ssh
iptables -A INPUT -p tcp -s any/0 --destination-port 22 -j ACCEPT
iptables -N icmp_allowed
iptables -A icmp_allowed -p ICMP --icmp-type 11 -j ACCEPT
iptables -A icmp_allowed -p ICMP --icmp-type 8 -j ACCEPT
iptables -A icmp_allowed -p ICMP -j DROP
iptables -A OUTPUT -p icmp -j ACCEPT
iptables -A INPUT -p icmp -j ACCEPT
iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT
iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT
/etc/init.d/iptables save


                               




                 
                 
                 
                 
                 
                 
                 SSH服务器端/etc/ssh/sshd_conf配置文件详解:
                 
                 cat /etc/ssh/sshd_config
                 
                 #Port 22                                          监听端口，默认监听22端口   【默认可修改】
                 #AddressFamily any                        IPV4和IPV6协议家族用哪个，any表示二者均有
                 #ListenAddress 0.0.0.0                   指明监控的地址，0.0.0.0表示本机的所有地址  【默认可修改】
                 #ListenAddress ::                            指明监听的IPV6的所有地址格式
                 # The default requires explicit activation of protocol 1   
                 #Protocol 2                                      使用SSH第二版本，centos7默认第一版本已拒绝
                 # HostKey for protocol version 1      一版的SSH支持以下一种秘钥形式
                 #HostKey /etc/ssh/ssh_host_key
                 # HostKeys for protocol version 2                  使用第二版本发送秘钥，支持以下四种秘钥认证的存放位置：（centos6只支持rsa和dsa两种）
                 HostKey /etc/ssh/ssh_host_rsa_key               rsa私钥认证 【默认】
                 #HostKey /etc/ssh/ssh_host_dsa_key            dsa私钥认证
                 HostKey /etc/ssh/ssh_host_ecdsa_key          ecdsa私钥认证
                 HostKey /etc/ssh/ssh_host_ed25519_key      ed25519私钥认证
                 # Lifetime and size of ephemeral version 1 server key
                 #KeyRegenerationInterval 1h
                 #ServerKeyBits 1024        主机秘钥长度        
                 # Ciphers and keying      
                 #RekeyLimit default none
                 # Logging
                 # obsoletes QuietMode and FascistLogging
                 #SyslogFacility AUTH
                 SyslogFacility AUTHPRIV                   当有人使用ssh登录系统的时候，SSH会记录信息，信息保存在/var/log/secure里面
                 #LogLevel INFO                                  日志的等级
                 # Authentication:
                 #LoginGraceTime 2m                           登录的宽限时间，默认2分钟没有输入密码，则自动断开连接
                 #PermitRootLogin no
                 PermitRootLogin yes                            是否允许管理员直接登录，'yes'表示允许
                 #StrictModes yes                                 是否让sshd去检查用户主目录或相关文件的权限数据
                 #MaxAuthTries 6                                  最大认证尝试次数，最多可以尝试6次输入密码。之后需要等待某段时间后才能再次输入密码
                 #MaxSessions 10                                 允许的最大会话数
                 #RSAAuthentication yes
                 #PubkeyAuthentication yes
                 # The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
                 # but this is overridden so installations will only check .ssh/authorized_keys
                 AuthorizedKeysFile .ssh/authorized_keys                 服务器生成一对公私钥之后，会将公钥放到.ssh/authorizd_keys里面，将私钥发给客户端
                 #AuthorizedPrincipalsFile none 
                 #AuthorizedKeysCommand none
                 #AuthorizedKeysCommandUser nobody
                 # For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
                 #RhostsRSAAuthentication no
                 # similar for protocol version 2
                 #HostbasedAuthentication no
                 # Change to yes if you don't trust ~/.ssh/known_hosts for
                 # RhostsRSAAuthentication and HostbasedAuthentication
                 #IgnoreUserKnownHosts no
                 # Don't read the user's ~/.rhosts and ~/.shosts files
                 #IgnoreRhosts yes
                 # To disable tunneled clear text passwords, change to no here!
                 #PasswordAuthentication yes
                 #PermitEmptyPasswords no
                 PasswordAuthentication yes                    是否允许支持基于口令的认证
                 # Change to no to disable s/key passwords
                 #ChallengeResponseAuthentication yes
                 ChallengeResponseAuthentication no     是否允许任何的密码认证
                 # Kerberos options                                   是否支持kerberos（基于第三方的认证，如LDAP）认证的方式，默认为no 
                 #KerberosAuthentication no
                 #KerberosOrLocalPasswd yes
                 #KerberosTicketCleanup yes
                 #KerberosGetAFSToken no
                 #KerberosUseKuserok yes
                 # GSSAPI options                                       
                 GSSAPIAuthentication yes
                 GSSAPICleanupCredentials no
                 #GSSAPIStrictAcceptorCheck yes
                 #GSSAPIKeyExchange no
                 #GSSAPIEnablek5users no
                 # Set this to 'yes' to enable PAM authentication, account processing,
                 # and session processing. If this is enabled, PAM authentication will
                 # be allowed through the ChallengeResponseAuthentication and
                 # PasswordAuthentication. Depending on your PAM configuration,
                 # PAM authentication via ChallengeResponseAuthentication may bypass
                 # the setting of "PermitRootLogin without-password".
                 # If you just want the PAM account and session checks to run without
                 # PAM authentication, then enable this but set PasswordAuthentication
                 # and ChallengeResponseAuthentication to 'no'.
                 # WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several
                 # problems.
                 UsePAM yes
                 #AllowAgentForwarding yes
                 #AllowTcpForwarding yes
                 #GatewayPorts no
                 X11Forwarding yes                    是否允许x11转发，可以让窗口的数据通过SSH连接来传递(请查看ssh -X 参数)：#ssh -X  user@IP
                 #X11DisplayOffset 10
                 #X11UseLocalhost yes 
                 #PermitTTY yes
                 #PrintMotd yes
                 #PrintLastLog yes
                 #TCPKeepAlive yes
                 #UseLogin no
                 UsePrivilegeSeparation sandbox # Default for new installations.
                 #PermitUserEnvironment no
                 #Compression delayed
                 #ClientAliveInterval 0
                 #ClientAliveCountMax 3
                 #ShowPatchLevel no
                 #UseDNS yes              是否反解DNS，如果想让客户端连接服务器端快一些，这个可以改为no
                 #PidFile /var/run/sshd.pid
                 #MaxStartups 10:30:100
                 #PermitTunnel no
                 #ChrootDirectory none
                 #VersionAddendum none
                 # no default banner path
                 #Banner none
                 # Accept locale-related environment variables
                 AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
                 AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
                 AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE
                 AcceptEnv XMODIFIERS
                 # override default of no subsystems
                 Subsystem sftp /usr/libexec/openssh/sftp-server                    支持 SFTP ，如果注释掉，则不支持sftp连接
                 # Example of overriding settings on a per-user basis
                 #Match User anoncvs
                 # X11Forwarding no
                 # AllowTcpForwarding no
                 # PermitTTY no
                 # ForceCommand cvs server
                 AllowUsers user1 user2                登录白名单（默认没有这个配置，需要自己手动添加），允许远程登录的用户。如果名单中没有的用户，则提示拒绝登录
                  
                 
                  
                 










SELinux安全防护:


               将Linux服务器的SELinux设为enforcing强制模式
               
               
               vim /etc/selinux/config
               SELINUX=enforcing                    //设置SELinux为强制模式
               SELINUXTYPE=targeted                 //保护策略为保护主要的网络服务安全
               
               2）临时配置：使用setenforce命令
               查看当前SELinux状态，如果是disabled则需要根据第1）步的配置重启系统；如果是permissive则使用setenforce命令修改为enforcing即可：
               getenforce                        //查看当前状态为警告模式
               Permissive
               setenforce 1                      //设置SELinux为强制模式
               getenforce                        //查看当前模式为强制模式
               Enforcing
               setenforce 0                      //设置SELinux为强制模式
               getenforce                        //查看当前模式为警告模式
               Permissive
               
               
               
               调整文件的安全上下文
               
               chcon -t public_content_t  file 
               
               注意：上例中的chcon操作可替换为（效果相同）：
               # restorecon /var/ftp/log2.tar.gz
               或者
               # chcon --reference=/var/ftp/log1.tar.gz /var/ftp/log2.tar.gz



文件系统与挂载：


                       文件系统管理相关命令




                    fdisk        # Linux分区表操作工具软件  
                    mke2fs       # 创建ext2/ext3/ext4文件系统  
                    blkid        # 定位或打印块设备属性信息  
                    e2lable      # 改变ext2/ext3/ext4文件系统的卷标  
                    tune2fs      # 调整文件系统参数信息  
                    dumpe2fs     # 显示文件系统超级块信息和块组描述符  
                    fsck         # 检查并修复Linux文件系统  
                    e2fsck       # 检查并修复ext系列文件系统  
                    mount        # 挂载文件系统  
                    fuser        # 报告进程使用的文件或是网络套接字  
                    free         # 显示系统中已用的和未用的内存总和  
                    du           # 报告磁盘空间使用情况  
                    df           # 报告文件系统磁盘空间的使用情况  
                    dd           # 复制文件并对原文件进行转化和格式化处理  
                    mknod        # 创建块设备文件或字符设备文件  



              1.fdisk

                fdisk - Partition table manipulator for Linux    # Linux分区表操作工具软件

                  SYNOPSIS
                    fdisk [-uc] [-b sectorsize] [-C cyls] [-H heads] [-S sects] device

                          交互式命令   
                      m：显示帮助信息 
                      p: 显示当前硬件的分区，包括没保存的改动
                      n: 创建新分区，e: 扩展分区，p: 主分区
                      d: 删除一个分区
                      w: 保存退出
                      q: 不保存退出
                      t: 修改分区类型，L: 查看所有支持的分区类型
                      l: 显示所有支持的分区类型

             2、mke2fs

                mke2fs - create an ext2/ext3/ext4 filesystem    # 创建ext2/ext3/ext4文件系统

               SYNOPSIS
                   mke2fs [options] DEVICE

                     -j：创建ext3类型文件系统
                     -b BLOCK_SIZE：指定块大小，默认为4096；可用取值为1024、2048或4096
                     -L LABEL：指定分区卷标
                     -m #：指定预留给超级用户的块数百分比，默认值为%5
                     -i #：用于指定为多少字节的空间创建一个inode，默认为8192；应为block的2^n倍
                     -t FSTYPE：指定文件系统类型
                     -N #：指定inode个数
                     -F：强制创建文件系统，不管其是否处于挂载状态
                     -E：用户指定额外文件系统属性
                     -q：执行时不显示任何信息，常用于脚本
                     -c：检查是否有损坏的区块

             3、blkid

                blkid - command-line utility to locate/print block device attributes # 定位或打印块设备属性信息

                SYNOPSIS
                blkid [options] [DEVICE]

                         -s <tag>：显示指定信息，默认显示所有信息
                         -o format：指定显示格式，常用list


             4、e2lable

                e2label - Change the label on an ext2/ext3/ext4 filesystem    # 改变ext2/ext3/ext4文件系统的卷标

                SYNOPSIS
                e2label device [ new-label ]
 
                e2label /dev/sdb1 SOYSAUCE          # 修改/dev/sdb1卷标
                e2label /dev/sdb1             # 查看/dev/sdb1卷标


             5、tune2fs

                tune2fs - adjust tunable filesystem parameters on ext2/ext3/ext4 filesystems # 调整文件系统参数信息

                SYNOPSIS
                tune2fs  [options]   DEVICE

                         -j：不损害原有数据，将ext2升级至ext3
                         -L LABEL：设定或修改卷标
                         -m #：调整预留百分比
                         -r #：指定预留块数
                         -o：设定默认挂载选项，常用的acl
                         -c #：指定挂载次数达到#次之后进行自检，0或-1表关闭此功能
                         -C #：指定文件系统已经被挂载的次数
                         -i #：每挂载使用多少天后进行自检；0或-1表示关闭此功能
                         -l：显示超级块中的信息


              6、dumpe2fs

                 dumpe2fs - dump ext2/ext3/ext4 filesystem information    # 显示文件系统超级块信息和块组描述符

                 SYNOPSIS
                 dumpe2fs  [options]  DEVICE
    
                           -h：查看超级块信息，但不包括GDT(块组描述表)


              7、fsck

                 fsck - check and repair a Linux file system    # 检查并修复Linux文件系统

                 SYNOPSIS 
                 -a：自动修复
                 -t FSTYPE：指定文件系统类型，可以不指，但一定不能指错

              8、e2fsck

                 e2fsck - check a Linux ext2/ext3/ext4 file system    # 检查并修复ext系列文件系统

                 SYNOPSIS
                 e2fsck  [options]  DEVICE

                          -f：强制检查
                          -p：自动修复


              9.Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。
           
                       语法
                    mount [-hV]
                    mount -a [-fFnrsvw] [-t vfstype]
                    mount [-fnrsvw] [-o options [,...]] device | dir
                    mount [-fnrsvw] [-t vfstype] [-o options] device dir
                       参数说明：
                          -V：显示程序版本
                          -h：显示辅助讯息
                          -v：显示较讯息，通常和 -f 用来除错。
                          -a：将 /etc/fstab 中定义的所有档案系统挂上。
                          -F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。
                          -f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。
                          -n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。
                          -s-r：等于 -o ro
                          -w：等于 -o rw
                          -L：将含有特定标签的硬盘分割挂上。
                          -U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。
                          -t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。
                          -o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。
                          -o sync：在同步模式下执行。
                          -o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。
                          -o auto、-o noauto：打开/关闭自动挂上模式。
                          -o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.
                          -o dev、-o nodev-o exec、-o noexec允许执行档被执行。
                          -o suid、-o nosuid：
                                       允许执行档在 root 权限下执行。
                          -o user、-o nouser：使用者可以执行 mount/umount 的动作。
                          -o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。
                          -o ro：用唯读模式挂上。
                          -o rw：用可读写模式挂上。
                          -o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。


              10、fuser

                  fuser - identify processes using files or sockets    # 报告进程使用的文件或是网络套接字

                  SYNOPSIS
                  fuser  [options]  DEVICE

                         -v：查看某文件上正在运行的进程
                         -k：杀死正在访问某文件的进程
                         -m：显示访问挂载点的进程

               11、free

                   free - Display amount of free and used memory in the system    # 显示系统中已用的和未用的内存总和

                   SYNOPSIS
                   free [-b | -k | -m] [-o] [-s delay ] [-t] [-l] [-V]

                         -m：以M为单位来显示

                   free -m
                                 total       used       free     shared    buffers     cached
                   Mem:           988        176        812          0         67         37
                   -/+ buffers/cache:         71        917    
                   Swap:         1983          0       1983        
                           第一行：内存总大小、已使用空间大小、剩余空间大小、共享内存、缓冲数据大小、缓存数据大小
                           第二行：UsedMem-(buffers+cached)为真实使用空间、FreeMem+(buffers+cached)为真实剩余空间
                           第三行：总交换分区大小、已使用交换分区大小、剩余交换分区大小


                12、du

                    du - estimate file space usage        # 报告磁盘空间使用情况

                    SYNOPSIS
                    du [OPTION]... [FILE]...
                    du [OPTION]... --files0-from=F

                       -s：仅显示总计，只列出最后加总的值
                       -h：做单位换算的

                    du -sh /root/        # 统计总大小
                            1.3M    /root/    
                    du -h /root/         # 统计目录下每单个文件大小


                 13、df

                     df - report file system disk space usage        # 报告文件系统磁盘空间的使用情况

                     SYNOPSIS
                     df [OPTION]... [FILE]...

                        -a：查看所有的文件系统
                        -h：做单位换算
                        -i：显示inode使用情况
                        -P：以POSIX风格显示
                        -T：显示文件系统类型

                      df -ihT            # 显示Inode使用情况

                  14、dd

                      dd - convert and copy a file        # 复制文件并对原文件进行转化和格式化处理

                      SYNOPSIS
                      dd [OPERAND]...
                      dd OPTION

                      if=数据来源
                      of=数据存储目录
                      bs=#：指定块大小，单位默认为字节，也可以指定M、G等
                      count=#：指定读取的块数
                      seek=#：创建数据文件时，跳过的空间大小

                      dd if=/dev/sda of=/root/mbr.back bs=512 count=1    # 备份mbr
                      1+0 records in
                      1+0 records out
                      512 bytes (512 B) copied, 0.000675345 s, 758 kB/s
                      dd if=/dev/zero of=/root/zerofile bs=1M count=1 seek=1023    # 跳过前面1023M，创建一个假的1G文件
                      1+0 records in
                      1+0 records out
                      1048576 bytes (1.0 MB) copied, 0.00649022 s, 162 MB/s
                      ll -h /root/zerofile     # ls看到的是假的1G
                      -rw-r--r-- 1 root root 1.0G Nov 24 11:07 /root/zerofile
                      du -sh /root/zerofile     # du看到的是真实的大小，为1M
                      1.0M    /root/zerofile

                 15、mknod

                     mknod - make block or character special files        # 创建块设备文件或字符设备文件

                     SYNOPSIS
                     mknod [OPTION]... NAME TYPE [MAJOR MINOR]

                     -m：设置权限
                     -Z：设置安全的上下文
 
                     mknod /dev/mydev b 65 0        # 创建一个主设备号为65 次设备号为0的块设备文件
                     ll /dev/mydev 
                     brw-r--r-- 1 root root 65, 0 Nov 24 11:34 /dev/mydev
                     mknod -m 600 /dev/mysdev b 65 1    # -m指定权限为600
                     ll /dev/mysdev 
                     brw------- 1 root root 65, 1 Nov 24 11:36 /dev/mysdev




# iostat用于输出CPU和磁盘I/O相关统计信息

# iostat可以显示CPU和I/O系统的负载情况及分区状态信息. 
直接执行iostat可以显示下面内容:

[wmt@template ~]$ iostat 
Linux 2.6.32-358.el6.x86_64 (template.xx.xx) 07/14/2017 _x86_64_(32 CPU)

avg-cpu:  %user  %nice %system %iowait  %steal  %idle
          2.93    0.00    0.20    0.04    0.00  96.83

Device:            tps  Blk_read/s  Blk_wrtn/s  Blk_read  Blk_wrtn
sda              0.66        6.60        14.79  462593198 1036802588
sdc              0.20        1.60        0.00  112173840          0
sdb              25.46      453.65      582.45 31805540026 40835922808
scd0              0.00        0.00        0.00      5012          0
dm-0            25.21      453.64      582.45 31805251514 40835922808
dm-1              1.89        6.35        14.55  445409130 1020026016
dm-2              0.06        0.24        0.24  17154880  16776296

# cpu段配置说明
avg-cpu 
%user： 用户空间使用CPU百分比
%nice ： nice使用
%system ： 系统(kernel)使用cpu百分比
%iowait ： cpu等待硬盘I/O时，所占用的百分比
%steal  ： 系统偷出CPU的百分比 (不知道什么鬼,求解释)
%idle： 系统空闲百分比

# Device磁盘段配置说明 
tps: 每秒钟发送到I/O请求数
Blk_read/s: 每秒从磁盘读出的的数据量，单位B
Blk_wrtn/s: 每秒从磁盘写入的的数据量，单位B
Blk_read: 开机始从磁盘读出的数据总量
Blk_wrtn: 开机始从磁盘写入的数据总量

            一、硬盘物理结构及相关概念

                           1.磁头(head)数：每个盘片一般有上下两面，分别对应1个磁头，共2个磁头,实现数据的存取

                           2.磁道(track)：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道，从外边缘的0开始编号，根据磁化方向来存数数据0和1

                           3.柱面(cylinder)：不同盘片的相同编号的磁道构成的圆柱面就被称之为柱面，磁盘的柱面数与一个盘面上的磁道数是相等的

                           4.扇区(sector)：每个磁道都别切分成很多扇形区域，每个磁道的扇区数量相同，每个扇区大小为512字节

                           5.圆盘(platter)：就是硬盘的盘片，为实现大容量，一般都是多个

                           6.硬盘的容量=柱面数×磁头数×扇区数×512（字节数）

            二、硬盘逻辑结构及相关概念

                          硬盘的0柱面、0磁头、1扇区称为主引导扇区（也叫主引导记录MBR）。它由三个部分组成：硬盘主引导程序(BootLoader)、硬盘分区表DPT（Disk Partition table）和魔数(Magic Number)。

                   1.Boot Loader：主引导程序，启动操作系统的一段代码，占446个字节

                   2.DPT：占64个字节，硬盘中分区有多少以及每一分区的大小都记在其中

                   3.Magic Number：占2个字节，固定为0xAA55或0x55AA，这取决于处理器类型，如果是小端模式处理器(如Intel系列)，则该值 为0xAA55；如果是大端模式处理器（如Motorola6800），则该值为0x55AA


            三、Ext2文件系统逻辑结构

                一个分区最开始处是Boot Sector，然后就是多个块组每个块组又可以细分为如下组成部分：

          1.Super Block：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；由于super block很重要 ，在每个 block group都会存一份进行备份.

          2.GDT：Group Descriptor Table，块组描述符，由很多块组描述符组成，整个分区分成多少个块组就对应有多少个块组描述符。每个块组描述符（Group Descriptor）存储一个块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。和超级块类似，块组描述符表在每个块组的开头也都有一份拷贝

          3.Block Bitmap：块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块，其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用

          4.inode Bitmap：和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用

          5.inode Table：一个文件除了数据需要存储之外，一些描述信息也需要存储，例如文件类型（常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间等，也就是ls-l命令看到的那些信息，这些信息存在inode中而不是数据块中，每个文件都有一个inode，一个块组中的所有inode组成了inode表，inode表占多少个块在格式化时就要决定并写入块组描述符中

          6.Data Blocks：对于常规文件，文件的数据存储在数据块中，对于目录，该目录下的所有文件名和目录名存储在数据块中，文件名保存在它所在目录的数据块中，除文件名之外，ls -l命令看到的其它信息都保存在该文件的inode中，目录也是一种文件，是一种特殊类型的文件，对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中



件系统详解



               一、文件系统层次分析

                   由上而下主要分为用户层、VFS层、文件系统层、缓存层、块设备层、磁盘驱动层、磁盘物理层

                   用户层：最上面用户层就是我们日常使用的各种程序，需要的接口主要是文件的创建、删除、打开、关闭、写、读等。 

             VFS层：我们知道Linux分为用户态和内核态，用户态请求硬件资源需要调用System Call通过内核态去实现。用户的这些文件相关操作都有对应的System Call函数接口，接口调用 VFS对应的函数。 

                   文件系统层：不同的文件系统实现了VFS的这些函数，通过指针注册到VFS里面。所以，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的作用。 

                   缓存层：文件系统底下有缓存，Page Cache，加速性能。对磁盘LBA的读写数据缓存到这里。

                   块设备层：块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行。Linux设计了电梯算法等对很多LBA的读写进行优化排序，尽量把连续地址放在一起。

                   磁盘驱动层：磁盘的驱动程序把对LBA的读写命令转化为各自的协议，比如变成ATA命令，SCSI命令，或者是自己硬件可以识别的自定义命令，发送给磁盘控制器。Host Based SSD甚至在块设备层和磁盘驱动层实现了FTL，变成对Flash芯片的操作。 

                   磁盘物理层：读写物理数据到磁盘介质。

               二、文件系统结构与工作原理（主要以ext4为例）

                   大体过程如下：

                   1、根据文件所在目录的inode信息，找到目录文件对应数据块

                   2、根据文件名从数据块中找到对应的inode节点信息

                   3、从文件inode节点信息中找到文件内容所在数据块块号

                   4、读取数据块内容

                  到这里，应该都已经非常清楚文件读取的过程了，那么下面再抛出两个疑问：

                   1、文件的拷贝、剪切的底层过程是怎样的？

                   2、软连接和硬连接分别是如何实现的？

                  下面来结合stat命令动手操作一下，便知真相：



                   1）拷贝文件：创建一个新的inode节点，并且拷贝数据块内容



                   2）剪切文件：同个分区里边mv，inode节点不变，只是更新目录文件对应数据块里边的文件名和inode对应关系；跨分区mv，则跟拷贝一个道理，需要创建新的inode，因为inode节点不同分区是不能共享的。



                   3）软连接：创建软连接会创建一个新的inode节点，其对应数据块内容存储所链接的文件名信息，这样原文件即便删除了，重新建立一个同名的文件，软连接依然能够生效。



                   4)硬链接：创建硬链接，并不会新建inode节点，只是links加1，还有再目录文件对应数据块上增加一条文件名和inode对应关系记录；只有将硬链接和原文件都删除之后，文件才会真正删除，即links为0才真正删除。


                三、文件顺序读写和随机读写


                   主要是因为Linux的文件系统会将文件分散在整个磁盘，在文件之间留有大量的自由空间，而不是像Windows那样将文件一个接一个的放  置。当一个文件被编辑了并且变大了，一般都会有足够的自由空间来保存文件。如果碎片真的产生了，文件系统就会尝试在日常使用中将文件移动来减少碎片，所以不需要专门的碎片整理程序。但是，如果磁盘空间占用已经快满了，那碎片是不可避免的，文件系统的设计本来就是用来满足正常情况下使用的。如果磁盘空间不够，那要么就是数据冗余了，要么就该换容量更大的磁盘。你可以使用fsck命令来检测一下一个Linux文件系统的碎片化程度，只需要在输出中查看非连续i节点个数（non-contiguous inodes）就可以了。

                四、读取、创建、删除、复制、剪切过程

                    1、读取文件：例如/etc/httpd/httpd.conf
                       首先根是自引用的，也就是根的Inode号是已知的，再根据Inode Table可以知道根的Inode号对应的Block号，然后找到对应的block，block里面有个目录项，也即Dentry，每个目录项记录了根下所有直接子目录的Inode与文件名的对应关系(也包括文件类型等)，例如var对应的Inode号为2883585，etc对应的Inode号为1507329等等，此时找到etc文件对应的Inode号，再通过查找Inode Table可以得知etc文件对应的Block，再通过读取Block里面的Dentry可以得知httpd文件对应的Inode，再查找Inode Table可以查到httpd文件对应的Block，再在对应的Block里面查询Dentry可以得知httpd.conf文件对应的Inode号，再次查询Inode Table可以找到对应的Block，于是数据就可以读取了

                    2、创建文件：例如/etc/testfile.txt
                       想要创建一个文件，首先得先给这个文件分配Inode和Block。首先扫描Inode Bitmap查找空闲Inode，再去Inode Table中写入想要创建文件的元数据，例如权限、属主属组、大小、时间戳、以及这个Inode对应所占据的Block。然后再找到根的Inode，找到根对应的Block，里面Dentry记录了etc及其对应的Inode，再通过Inode Table找到etc文件对应的Block，于是在Dentry里面添加一条记录，testfile.txt与其对应的Inode号，文件类型等信息。到此一个文件便创建了。

                    3、删除文件：例如/etc/fstab
                       删除文件直接上级目录(etc)里面的那条Dentry记录，Inode Bitmap里面把文件(fstab)原先对应的Inode号标记为未使用，Block Bitmap中把文件(fstab)原先对应的Block标记为未使用。删除文件本身并没有删除文件所对应的Block和Inode，也就是说Block上的数据并没有被抹除，除非后面向其Block中覆盖数据

                    4、复制文件
                       复制文件本质就是新建一个文件，并填充源文件数据的过程，详细可参考上面的创建和读取文件过程

                    5、剪切文件
                       在同一个分区下，剪切速度非常快，这是因为其本质也只是将Dentry记录换一个目录而已，所以根本就不涉及什么耗时的操作。而跨分区剪切文件的过程其实就是在另外一个分区上创建一个新文件，并复制，复制完成之后再删除原先分区上数据的一个过程。

                 五、软连接与硬链接联系与区别


                     软连接(符号链接)与硬链接区别

                     硬链接
                     ①只能对文件创建，不能应用于目录
                     ②不能跨文件系统
                     ③创建硬链接会增加文件被链接的次数
                     ④硬链接次数为1时，再删除就是彻底删除了
                     ⑤删除源文件不会影响链接文件
                     软链接：
                     ①可应用于目录
                     ②可以跨文件系统
                     ③不会增加被链接文件的链接次数
                     ④其大小为指定的路径所包含的字符个数
                     ⑤删除源文件会影响链接文件
                     硬链接与复制的区别

                     互为硬链接的两文件inode号肯定是相同的，对应的block号也是相同的；而复制的文件inode号和block号也肯定不相同，只是block里面存储的数据是一样而已

                六、虚拟文件系统



              Linux 中允许众多不同的文件系统共存，如 ext2, ext3, vfat 等。通过使用同一套文件 I/O 系统 调用即可对 Linux 中的任意文件进行操作而无需考虑其所在的具体文件系统格式；更进一步，对文件的 操作可以跨文件系统而执行。

                  “一切皆是文件”是 Unix/Linux 的基本哲学之一。不仅普通的文件，目录、字符设备、块设备、 套接字等在 Unix/Linux 中都是以文件被对待；它们虽然类型不同，但是对其提供的却是同一套操作界面。

                    概括说来，VFS主要有以下几个作用：

                    1.对具体文件系统的数据结构进行抽象，以一种统一的数据结构进行管理。

                    2.接受用户层的系统调用 ，例如write、open、stat、link等等。

                    3.支持多种具体文件系统之间相互访问。

                    4.接受内核其他子系统的操作请求，特别是内存管理子系统


              VFS数据结构

                    一些基本概念

                    从本质上讲，文件系统是特殊的数据分层存储结构，它包含文件、目录和相关的控制信息。为了描述 这个结构，Linux引入了一些基本概念:

                    1.文件 一组在逻辑上具有完整意义的信息项的系列。在Linux中，除了普通文件，其他诸如目录、设备、套接字等 也以文件被对待。总之，“一切皆文件”。

                    2.目录 目录好比一个文件夹，用来容纳相关文件。因为目录可以包含子目录，所以目录是可以层层嵌套，形成 文件路径。在Linux中，目录也是以一种特殊文件被对待的，所以用于文件的操作同样也可以用在目录上。

                    3.目录项 在一个文件路径中，路径中的每一部分都被称为目录项；如路径/home/source/helloworld.c中，目录 /, home, source和文件 helloworld.c都是一个目录项。

                    4.索引节点 用于存储文件的元数据的一个数据结构。文件的元数据，也就是文件的相关信息，和文件本身是两个不同 的概念。它包含的是诸如文件的大小、拥有者、创建时间、磁盘位置等和文件相关的信息。

                   5.超级块 用于存储文件系统的控制信息的数据结构。描述文件系统的状态、文件系统类型、大小、区块数、索引节 点数等，存放于磁盘的特定扇区中。


                   关于文件系统的三个易混淆的概念：

                   创建 以某种方式格式化磁盘的过程就是在其之上建立一个文件系统的过程。创建文现系统时，会在磁盘的特定位置写入 关于该文件系统的控制信息。

                   注册 向内核报到，声明自己能被内核支持。一般在编译内核的时侯注册；也可以加载模块的方式手动注册。注册过程实 际上是将表示各实际文件系统的数据结构struct file_system_type 实例化。

                   安装 也就是我们熟悉的mount操作，将文件系统加入到Linux的根文件系统的目录树结构上；这样文件系统才能被访问。

                   跨文件系统的文件操作的基本原理

                   到此，我们也就能够解释在Linux中为什么能够跨文件系统地操作文件了。举个例子，将vfat格式的磁盘上的一个文件a.txt拷贝到ext3格式的磁 盘上，命名为b.txt。这包含两个过程，对a.txt进行读操作，对b.txt进行写操作。读写操作前，需要先打开文件。由前面的分析可知，打开文件 时，VFS会知道该文件对应的文件系统格式，以后操作该文件时，VFS会调用其对应的实际文件系统的操作方法。所以，VFS调用vfat的读文件方法将 a.txt的数据读入内存；在将a.txt在内存中的数据映射到b.txt对应的内存空间后，VFS调用ext3的写文件方法将b.txt写入磁盘；从而 实现了最终的跨文件系统的复制操作










                                                               

