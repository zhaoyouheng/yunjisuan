	系统基本操作 & 软件工具操作  3-31

常用便捷操作：
	Ctrl+C		结束当前任务
	Ctrl+Z		暂停当前任务并放至后台
	Ctrl+Shift+T	新建终端页
 	Ctrl+Shift+V	粘贴
	Ctrl+L		清屏
	Ctrl+U		回删整行
	Ctrl+W		回删一个单词
      Ctrl+A/Home        将光标移动到行首
      Ctrl+E/End         将光标移动到行尾            
      Ctrl+D             一般为结束输入
      Ctrl+S             挂起，冻结终端
      Ctrl+Q             解除冻结终端
	Tab			补全
	！+任意命令开头	重复上一条以此开头的命令
	Esc+ . 		粘贴上条命令的参数
	?			匹配任意一个字符
	*			匹配任意字串
	[ ]			匹配包含在连续范围内的一个字符
	{}			匹配包含在一组字串组内的字串
	^+字串		匹配以该字串开头的所有字串
	字串+$		匹配以该字串结尾的所有字串
	^$			匹配空行
	~ 、 . 、 ..		在路径中使用的符号
	>、>>、<、2>、&>	重定向
	|			管道
	#			注释
	#!			环境声明
	$#			已加在的未知变量的个数（使用的未知变量总数）
	$*			所有未知变量的值
	$?			上一条命令的报错次数
	$RANDOM		在0-32767范围内随机一个数字
	$USER			登陆的用户名
	$PATH			储存命令的搜寻路径
	$HISTSIZE		历史命令的最大储存数

shell 常用的一些新命令
column
用法：
 column [选项] [文件 ...]

选项：
 -c, --columns <宽度>     输出宽度(字符数)
 -t, --table              创建表格
 -s, --separator <字符串> 可用的表格分隔符
 -o, --output-separator <字符串>
                          表格输出列分隔符，默认为两个空格
 -x, --fillrows           先填充行，再填充列

 -h, --help     显示此帮助并退出
 -V, --version  输出版本信息并退出


sort 
用法：sort [选项]... [文件]...
　或：sort [选项]... --files0-from=F
Write sorted concatenation of all FILE(s) to standard output.

Mandatory arguments to long options are mandatory for short options too.
排序选项：

  -b, --ignore-leading-blanks	忽略前导的空白区域
  -d, --dictionary-order	只考虑空白区域和字母字符
  -f, --ignore-case		忽略字母大小写
  -g, --general-numeric-sort  compare according to general numerical value
  -i, --ignore-nonprinting    consider only printable characters
  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'
  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)
  -n, --numeric-sort		根据字符串数值比较
  -R, --random-sort		根据随机hash 排序
      --random-source=文件	从指定文件中获得随机字节
  -r, --reverse			逆序输出排序结果
      --sort=WORD		按照WORD 指定的格式排序：
					一般数字-g，高可读性-h，月份-M，数字-n，
					随机-R，版本-V
  -V, --version-sort		在文本内进行自然版本排序

其他选项：

      --batch-size=NMERGE	一次最多合并NMERGE 个输入；如果输入更多
					则使用临时文件
  -c, --check, --check=diagnose-first	检查输入是否已排序，若已有序则不进行操作
  -C, --check=quiet, --check=silent	类似-c，但不报告第一个无序行
      --compress-program=程序	使用指定程序压缩临时文件；使用该程序
					的-d 参数解压缩文件
      --debug			为用于排序的行添加注释，并将有可能有问题的
					用法输出到标准错误输出
      --files0-from=文件	从指定文件读取以NUL 终止的名称，如果该文件被
					指定为"-"则从标准输入读文件名
  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type
  -m, --merge               merge already sorted files; do not sort
  -o, --output=文件		将结果写入到文件而非标准输出
  -s, --stable			禁用last-resort 比较以稳定比较算法
  -S, --buffer-size=大小	指定主内存缓存大小
  -t, --field-separator=分隔符	使用指定的分隔符代替非空格到空格的转换
  -T, --temporary-directory=目录	使用指定目录而非$TMPDIR 或/tmp 作为
					临时目录，可用多个选项指定多个目录
      --parallel=N		将同时运行的排序数改变为N
  -u, --unique		配合-c，严格校验排序；不配合-c，则只输出一次排序结果
  -z, --zero-terminated	以0 字节而非新行作为行尾标志
      --help		显示此帮助信息并退出
      --version		显示版本信息并退出
uniq
命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。

语法

uniq(选项)(参数)
选项

-c或——count：在每列旁边显示该行重复出现的次数；
-d或--repeated：仅显示重复出现的行列；
-f<栏位>或--skip-fields=<栏位>：忽略比较指定的栏位；
-s<字符位置>或--skip-chars=<字符位置>：忽略比较指定的字符；
-u或——unique：仅显示出一次的行列；
-w<字符位置>或--check-chars=<字符位置>：指定要比较的字符。




xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs的默认命令是echo，空格是默认定界符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。xargs是构建单行命令的重要组件之一。

xargs命令用法

xargs用作替换工具，读取输入数据重新格式化后输出。

定义一个测试文件，内有多行文本数据：

cat test.txt

a b c d e f g
h i j k l m n
o p q
r s t
u v w x y z
多行输入单行输出：

cat test.txt | xargs

a b c d e f g h i j k l m n o p q r s t u v w x y z
-n选项多行输出：

cat test.txt | xargs -n3

a b c
d e f
g h i
j k l
m n o
p q r
s t u
v w x
y z
-d选项可以自定义一个定界符：

echo "nameXnameXnameXname" | xargs -dX

name name name name
结合-n选项使用：

echo "nameXnameXnameXname" | xargs -dX -n2

name name
name name
读取stdin，将格式化后的参数传递给命令

假设一个命令为 sk.sh 和一个保存参数的文件arg.txt：

#!/bin/bash
#sk.sh命令内容，打印出所有参数。

echo $*
arg.txt文件内容：

cat arg.txt

aaa
bbb
ccc
xargs的一个选项-I，使用-I指定一个替换字符串{}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次：

cat arg.txt | xargs -I {} ./sk.sh -p {} -l

-p aaa -l
-p bbb -l
-p ccc -l
复制所有图片文件到 /data/images 目录下：

ls *.jpg | xargs -n1 -I cp {} /data/images
xargs结合find使用

用rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用xargs去避免这个问题：

find . -type f -name "*.log" -print0 | xargs -0 rm -f
xargs -0将\0作为定界符。

统计一个源代码目录中所有php文件的行数：

find . -type f -name "*.php" -print0 | xargs -0 wc -l
查找所有的jpg 文件，并且压缩它们：

find . -type f -name "*.jpg" -print | xargs tar -czvf images.tar.gz
xargs其他应用

假如你有一个文件包含了很多你希望下载的URL，你能够使用xargs下载所有链接：

cat url-list.txt | xargs wget -c
子Shell（Subshells）

运行一个shell脚本时会启动另一个命令解释器.，就好像你的命令是在命令行提示下被解释的一样，类似于批处理文件里的一系列命令。每个shell脚本有效地运行在父shell(parent shell)的一个子进程里。这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程。

cmd1 | ( cmd2; cmd3; cmd4 ) | cmd5
如果cmd2 是cd /，那么就会改变子Shell的工作目录，这种改变只是局限于子shell内部，cmd5则完全不知道工作目录发生的变化。子shell是嵌在圆括号()内部的命令序列，子Shell内部定义的变量为局部变量。

子shell可用于为一组命令设定临时的环境变量：

COMMAND1
COMMAND2
COMMAND3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  COMMAND4
  COMMAND5
  exit 3 # 只是从子shell退出。
)
# 父shell不受影响，变量值没有更改。
COMMAND6
COMMAND7

什么是shell？


        Shell是在Linux内核与用户之间的解释器程序，通常指的是bash，负责向内核翻译及传达用户/程序指令


           一个规范的Shell脚本构成包括：

                    脚本声明（需要的解释器、作者信息等）

                    注释信息（步骤、思路、用途、变量含义等）

                    可执行语句（操作代码）


用法：tr [选项]... SET1 [SET2]
从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。

  -c, -C, --complement		首先补足SET1
  -d, --delete			删除匹配SET1 的内容，并不作替换
  -s, --squeeze-repeats	如果匹配于SET1 的字符在输入序列中存在连续的
				重复，在替换时会被统一缩为一个字符的长度
  -t, --truncate-set1		先将SET1 的长度截为和SET2 相等
      --help		显示此帮助信息并退出
      --version		显示版本信息并退出

SET 是一组字符串，一般都可按照字面含义理解。解析序列如下：

  \NNN	八进制值为NNN 的字符(1 至3 个数位)
  \\		反斜杠
  \a		终端鸣响
  \b		退格
  \f		换页
  \n		换行
  \r		回车
  \t		水平制表符
  \v		垂直制表符
  字符1-字符2	从字符1 到字符2 的升序递增过程中经历的所有字符
  [字符*]	在SET2 中适用，指定字符会被连续复制直到吻合设置1 的长度
  [字符*次数]	对字符执行指定次数的复制，若次数以 0 开头则被视为八进制数
  [:alnum:]	所有的字母和数字
  [:alpha:]	所有的字母
  [:blank:]	所有呈水平排列的空白字符
  [:cntrl:]	所有的控制字符
  [:digit:]	所有的数字
  [:graph:]	所有的可打印字符，不包括空格
  [:lower:]	所有的小写字母
  [:print:]	所有的可打印字符，包括空格
  [:punct:]	所有的标点字符
  [:space:]	所有呈水平或垂直排列的空白字符
  [:upper:]	所有的大写字母
  [:xdigit:]	所有的十六进制数
  [=字符=]	所有和指定字符相等的字符

仅在SET1 和SET2 都给出，同时没有-d 选项的时候才会进行替换。
仅在替换时才可能用到-t 选项。如果需要SET2 将被通过在末尾添加原来的末字符的方式
补充到同SET1 等长。SET2 中多余的字符将被省略。只有[:lower:] 和[:upper:]
以升序展开字符；在用于替换时的SET2 中以成对表示大小写转换。-s 作用于SET1，既不
替换也不删除，否则在替换或展开后使用SET2 缩减。

curl(选项)(参数)
选项

-a/--append	上传文件时，附加到目标文件
-A/--user-agent <string>	设置用户代理发送给服务器
-anyauth	可以使用“任何”身份验证方法
-b/--cookie <name=string/file>	cookie字符串或文件读取位置
     --basic	使用HTTP基本验证
-B/--use-ascii	使用ASCII /文本传输
-c/--cookie-jar <file>	操作结束后把cookie写入到这个文件中
-C/--continue-at <offset>	断点续转
-d/--data <data>	HTTP POST方式传送数据
     --data-ascii <data>	以ascii的方式post数据
     --data-binary <data>	以二进制的方式post数据
     --negotiate	使用HTTP身份验证
     --digest	使用数字身份验证
     --disable-eprt	禁止使用EPRT或LPRT
     --disable-epsv	禁止使用EPSV
-D/--dump-header <file>	把header信息写入到该文件中
     --egd-file <file>	为随机数据(SSL)设置EGD socket路径
     --tcp-nodelay	使用TCP_NODELAY选项
-e/--referer	来源网址
-E/--cert <cert[:passwd]>	客户端证书文件和密码 (SSL)
     --cert-type <type>	证书文件类型 (DER/PEM/ENG) (SSL)
     --key <key>	私钥文件名 (SSL)
     --key-type <type>	私钥文件类型 (DER/PEM/ENG) (SSL)
     --pass <pass>	私钥密码 (SSL)
     --engine <eng>	加密引擎使用 (SSL). "--engine list" for list
     --cacert <file>	CA证书 (SSL)
     --capath <directory>	CA目录 (made using c_rehash) to verify peer against (SSL)
     --ciphers <list>	SSL密码
     --compressed	要求返回是压缩的形势 (using deflate or gzip)
     --connect-timeout <seconds>	设置最大请求时间
     --create-dirs	建立本地目录的目录层次结构
     --crlf	上传是把LF转变成CRLF
-f/--fail	连接失败时不显示http错误
     --ftp-create-dirs	如果远程目录不存在，创建远程目录
     --ftp-method [multicwd/nocwd/singlecwd]	控制CWD的使用
     --ftp-pasv	使用 PASV/EPSV 代替端口
     --ftp-skip-pasv-ip	使用PASV的时候,忽略该IP地址
     --ftp-ssl	尝试用 SSL/TLS 来进行ftp数据传输
     --ftp-ssl-reqd	要求用 SSL/TLS 来进行ftp数据传输
-F/--form <name=content>	模拟http表单提交数据
     --form-string <name=string>	模拟http表单提交数据
-g/--globoff	禁用网址序列和范围使用{}和[]
-G/--get	以get的方式来发送数据
-H/--header <line>	自定义头信息传递给服务器
     --ignore-content-length	忽略的HTTP头信息的长度
-i/--include	输出时包括protocol头信息
-I/--head	只显示请求头信息
-j/--junk-session-cookies	读取文件进忽略session cookie
     --interface <interface>	使用指定网络接口/地址
     --krb4 <level>	使用指定安全级别的krb4
-k/--insecure	允许不使用证书到SSL站点
-K/--config	指定的配置文件读取
-l/--list-only	列出ftp目录下的文件名称
     --limit-rate <rate>	设置传输速度
     --local-port<NUM>	强制使用本地端口号
-m/--max-time <seconds>	设置最大传输时间
     --max-redirs <num>	设置最大读取的目录数
     --max-filesize <bytes>	设置最大下载的文件总量
-M/--manual	显示全手动
-n/--netrc	从netrc文件中读取用户名和密码
     --netrc-optional	使用 .netrc 或者 URL来覆盖-n
     --ntlm	使用 HTTP NTLM 身份验证
-N/--no-buffer	禁用缓冲输出
-o/--output	把输出写到该文件中
-O/--remote-name	把输出写到该文件中，保留远程文件的文件名
-p/--proxytunnel	使用HTTP代理
     --proxy-anyauth	选择任一代理身份验证方法
     --proxy-basic	在代理上使用基本身份验证
     --proxy-digest	在代理上使用数字身份验证
     --proxy-ntlm	在代理上使用ntlm身份验证
-P/--ftp-port <address>	使用端口地址，而不是使用PASV
-q	作为第一个参数，关闭 .curlrc
-Q/--quote <cmd>	文件传输前，发送命令到服务器
-r/--range <range>	检索来自HTTP/1.1或FTP服务器字节范围
--range-file	读取（SSL）的随机文件
-R/--remote-time	在本地生成文件时，保留远程文件时间
     --retry <num>	传输出现问题时，重试的次数
     --retry-delay <seconds>	传输出现问题时，设置重试间隔时间
     --retry-max-time <seconds>	传输出现问题时，设置最大重试时间
-s/--silent	静默模式。不输出任何东西
-S/--show-error	显示错误
     --socks4 <host[:port]>	用socks4代理给定主机和端口
     --socks5 <host[:port]>	用socks5代理给定主机和端口
     --stderr <file>	 
-t/--telnet-option <OPT=val>	Telnet选项设置
     --trace <file>	对指定文件进行debug
     --trace-ascii <file>	Like --跟踪但没有hex输出
     --trace-time	跟踪/详细输出时，添加时间戳
-T/--upload-file <file>	上传文件
     --url <URL>	Spet URL to work with
-u/--user <user[:password]>	设置服务器的用户和密码
-U/--proxy-user <user[:password]>	设置代理用户名和密码
-w/--write-out [format]	什么输出完成后
-x/--proxy <host[:port]>	在给定的端口上使用HTTP代理
-X/--request <command>	指定什么命令
-y/--speed-time	放弃限速所要的时间，默认为30
-Y/--speed-limit	停止传输速度的限制，速度时间


wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。

语法

wget(选项)(参数)
选项

-a<日志文件>：在指定的日志文件中记录资料的执行过程；
-A<后缀名>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；
-b：进行后台的方式运行wget；
-B<连接地址>：设置参考的连接地址的基地地址；
-c：继续执行上次终端的任务；
-C<标志>：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；
-d：调试模式运行指令；
-D<域名列表>：设置顺着的域名列表，域名之间用“，”分隔；
-e<指令>：作为文件“.wgetrc”中的一部分执行指定的指令；
-h：显示指令帮助信息；
-i<文件>：从指定文件获取要下载的URL地址；
-l<目录列表>：设置顺着的目录列表，多个目录用“，”分隔；
-L：仅顺着关联的连接；
-r：递归下载方式；
-nc：文件存在时，下载文件不覆盖原有文件；
-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；
-q：不显示指令执行过程；
-nh：不查询主机名称；
-v：显示详细执行过程；
-V：显示版本信息；
--passive-ftp：使用被动模式PASV连接FTP服务器；
--follow-ftp：从HTML文件中下载FTP连接文件。
参数

set命令作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号"+"和"-"的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用declare命令以变量名=值的格式进行定义即可。

语法

set(选项)(参数)
选项

-a：标示已修改的变量，以供输出至环境变量。
-b：使被中止的后台程序立刻回报执行状态。
-C：转向所产生的文件无法覆盖已存在的文件。
-d：Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。
-e：若指令传回值不等于0，则立即退出shell。
-f：取消使用通配符。
-h：自动记录函数的所在位置。
-H Shell：可利用"!"加<指令编号>的方式来执行history中记录的指令。
-k：指令所给的参数都会被视为此指令的环境变量。
-l：记录for循环的变量名称。
-m：使用监视模式。
-n：只读取指令，而不实际执行。
-p：启动优先顺序模式。
-P：启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。
-t：执行完随后的指令，即退出shell。
-u：当执行时使用到未定义过的变量，则显示错误信息。
-v：显示shell所读取的输入值。
-x：执行指令后，会先显示该指令及所下的参数。

seq命令用于产生从某个数到另外一个数之间的所有整数。

语法

seq [选项]... 尾数
seq [选项]... 首数 尾数
seq [选项]... 首数 增量 尾数
选项

-f, --format=格式        使用printf 样式的浮点格式
-s, --separator=字符串   使用指定字符串分隔数字（默认使用：\n）
-w, --equal-width        在列前添加0 使得宽度相同




wait命令用来等待指令的指令，直到其执行完毕后返回终端。该指令常用于shell脚本编程中，待指定的指令执行完成后，才会继续执行后面的任务。该指令等待作业时，在作业标识号前必须添加备份号"%"。

语法

wait(参数)
参数

进程或作业标示：指定进程号或者作业号。

实例

使用命令wait等待作业号为1的作业完成后再返回，输入如下命令：

wait %1



\t 是一个转义字符就像\n是表示换行,\t表示一个制表符，说白一点就是在文本框里输入信息时敲了下Tab键
下面是这些字符及其含义: 　　　　\b　　Backspace 　　　　\c　　显示后不换行 　　　　\f　　在终端上屏幕的开始处显示 　　　　\n　　换行 　　　　\r　　回车 　　　　\t　　制表符 　　　　\v　　垂直制表符 　　　　\　　 反斜框 　　　　\0nnn 用1,2或3位8进制整数表示一个ASCII码字符 
\t例子:
echo -e "a\tb" 输出的就是a    b，a与b中间的空位就是水平制表（制表符）。
推荐参考书籍：Shell脚本学习指南
shell的使用方式：
          1.交互执行指令：人工干预，执行效率底。

          2.非交互执行指令：安静地在后台执行，执行效率高，方便写脚本。

         若需要临时使用另一种Shell环境，可以直接执行对应的Shell解释器程序，
         比如只要执行ksh可以切换到ksh命令行环境。

                          cat /etc/shells
                              /bin/sh
                              /bin/bash
                              /sbin/nologin
                              /bin/tcsh
                              /bin/csh
                              /bin/ksh                                        //确认当前系统已识别ksh
                               ksh                                            //进入ksh环境
                               exit                                           //退回上一个shell  





           修改用户的登录Shell

                      usermod -s shell解释器  用户名
                           
                      useradd -s shell解释器  用户名


Shell脚本的执行方式：
            方法一，作为“命令字”：指定脚本文件的路径，前提是有 x 权限
                   ./first.sh                                //指定相对路径
                   /root/first.sh                            //指定绝对路径
            方法二，作为“参数”：使用bash、sh、source来加载脚本文件
                   bash   first.sh                           //开启子进程
                   sh        first.sh                        //开启子进程
                   source first.sh                           //不开启子进程
命令历史：

            检查历史命令的容量

            默认记录1000条，通过全局变量HISTSIZE设置，对所有用户有效：

           grep HISTSIZE /etc/profile

           HISTSIZE=1000

            查看已为当前用户记录的历史命令条数：

           history | wc -l



            调用指定的历史命令

               重新执行历史命令列表中的第1028条操作：

               !1028

             重新执行最近一次以cat开头（根据实际情况变更）的历史命令操作：


            !cat

             清空历史的命令

            history -c                         //清空自己的历史命令
            > ~/.bash_history                  //清空记录文件
            history                            //再次检查历史命令列表
  
命令别名:
                  1）查看已经定义的命令别名列表。
                  当前的别名列表：
                   alias
                   alias cp='cp -i'
                   alias l.='ls -d .* --color=tty'
                   alias ll='ls -l --color=tty'

                  别名设置一般存放在用户的.bashrc文件内：
                   grep '^alias' ~/.bashrc
                   alias rm='rm -i'
                   alias cp='cp -i'
                   alias mv='mv -i'
                  2）自定义新的命令别名
                   添加一个名为lh的命令别名，实际执行的是“ls -lh”：
                   alias lh='ls -lh'                      //定义别名命令lh
                   alias lh                              //确认定义结果
                   alias lh='ls -lh'
                    验证别名命令的效果：
                   lh /etc/fstab                          //使用别名
                   -rw-r--r-- 1 root root 733 10-09 15:34 /etc/fstab
                   ls -lh /etc/fstab                      //使用完整的命令
                   -rw-r--r-- 1 root root 733 10-09 15:34 /etc/fstab
                   3）取消别名
                        取消单个别名：
                   unalias lh                          //取消名为lh的命令别名
                   alias lh                              //查询时已没有lh
                   -bash: alias: lh: not found



重定向标准输入/输出/错误输出

                       标准输入（stdin），描述号为0；
                       标准输出（stdout），描述号为1；
                       标准错误（stderr），描述号为2。

             1）重定向标准输出。
                    使用 > 将命令执行的正常输出重定向到文件：
                  ls -ld /etc/                                            //正常应输出到屏幕
                  drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
                  ls -ld /etc/ > stdout.txt                               //重定向到文件
                  cat stdout.txt                                          //确认重定向输出的结果
                  drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/

                              > 操作会覆盖目标文件（先清空、再写入）：

                  echo "I am the king." > stdout.txt                      //覆盖目标文件
                  cat stdout.txt                                          //确认结果
                  I am the king.
                    改用 >> 可实现追加重定向输出：
                  ls -ld /etc/  >> stdout.txt                             //追加输出
                  cat stdout.txt
                  I am the king.                                          //原有内容还保留
                  drwxr-xr-x. 140 root root 8192 8月   2 04:45 /etc/
              2）重定向标准错误。

                     对于命令执行出错的信息，使用 > 无法保存，仍然会输出到屏幕。
                     比如，可使用ls命令同时查看两个对象（其中nb.txt并不存在），重定向输出：

                ls -l nb.txt /etc/fstab > stderr.txt
                cat stderr.txt                  //正常信息成功重定向到目标文件
                -rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
                    使用 2> 可重定向错误信息，比如，可执行一个错误的命令：

                ls -l nb.txt /etc/fstab 2> stderr.txt 
               -rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
                    //正确的信息默认输出至屏幕，错误信息重定向到目标文件 
               cat stderr.txt                        //从文件中查看出错信息
               ls: nb.txt: 没有那个文件或目录

                 类似的，2>> 可实现追加输出：

                ls tmpfile 2>> stderr.txt
                cat stderr.txt
                ls: nb.txt: 没有那个文件或目录
                ls: tmpfile: 没有那个文件或目录

                    若希望将正常输出、错误输出重定向同一个文件，可使用 &> :

               ls -l nb.txt /etc/fstab &> stderr.txt
               cat stderr.txt
               ls: nb.txt: 没有那个文件或目录
               -rw-r--r--. 1 root root 541 1月   5 2017 /etc/fstab
              3）重定向标准输入。

               mail -s Error  root   < /etc/passwd


管道操作实践:

                  借助于管道符“|”，可以将一条命令的标准输出交给另一条命令处理，在一条命令行内可依次使用多个管道。
                 1）统计/etc/目录下资料的数量。
               ls -l /etc | wc -l
                    254


使用Shell变量:



                变量的定义/赋值/查看:

                    1）新建/赋值变量
                    新建变量test，赋值“hello world”，通过set命令可以检查变量设置：
                  test=11
                    2）查看变量
                    通过echo $变量名 可输出变量值：
                  echo $test
                       11
                 查看变量时，若变量名称与后面要输出的字符串连在一起，则应该以{}将变量名括起来以便区分：

                  echo $testRMB              //无法识别变量名test

                  echo ${test}RMB            //区分后可以识别
                  11RMB

                     3）撤销自定义变量
                    若要撤销已有的变量，可使用unset命令：
                  unset test                  //撤销变量test
                  echo $test                  //查看时已无结果



使用环境变量:

                    1）查看环境变量相关文件
                     全局配置文件为/etc/profile，对所有用户有效；
                     用户配置文件为~/.bash_profile，仅对指定的用户有效。
                         查看/etc/profile文件内容：
                         cat /etc/profile
                                .. ..
                         HOSTNAME=`/bin/hostname`
                         HISTSIZE=1000
                                .. ..
                         export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC
                                .. ..
                   2）使用环境变量
                                 当前用户的环境变量USER记录了用户名、HOME记录了宿主目录：

                          SHELL记录了登录Shell、HOSTNAME记录主机名、UID是用户的id号：

                          echo $USER $HOME $SHELL $UID
                          root /root /bin/bash 0
                          
                          echo $HOSTNAME
                          svr5
                     环境变量PS1：
                                  表示Shell环境的一级提示符，即命令行提示符（\u 用户名、\h 主机名、\W 工作目录、\$ 权限标识）：
                           echo $PS1                                  //查看默认的一级提示
                           [\u@\h \W]\$
                           PS1='hehe#'                                //修改一级提示
                           hehe#                                      //更改结果
                           hehe# PS1='[\u@\h \W]\$ '                  //恢复原有设置
                           [root@svr5 src]# 

                      环境变量PS2：
                                   表示二级提示符，出现在强制换行、at任务编辑等场合：
                            echo $PS2                                //查看默认的二级提示
                                     >
                            cd \                                     //强制换行，观察提示符效果
                             > /root/
             
                            PS2='=> '                                //手动修改二级提示
                            cd \                                     //再次验证提示符效果
                                    => ~
                            PS2='> '                                 //恢复原有设置
                    3）查看系统变量
                            使用env可查看所有环境变量：

                        env
                            HOSTNAME=svr5.tarena.com
                            SHELL=/bin/bash
                            HISTSIZE=1000
                            SSH_CLIENT=192.168.4.110 59026 22
                            OLDPWD=/root
                            SSH_TTY=/dev/pts/0
                            USER=root
                                    .. ..

                            使用set可查看所有变量（包括env能看到的环境变量）：
                      
                        set
                            BASH=/bin/bash
                            BASH_ARGC=()
                            BASH_ARGV=()
                            BASH_LINENO=()
                                    .. ..
使用位置变量与预定义变量:

                             1）创建一个测试脚本，用来展示。
                         
                        vim location.sh
                        #!/bin/bash
                        echo $0                                        //脚本的名称
                        echo $1                                        //第一个参数
                        echo $2                                        //第二个参数
                        echo $*                                        //所有参数
                        echo $#                                        //所有的综合
                        echo $$                                        //当前进程的进程号
                        echo $?                                        //上一个程序的返回状态码

使用read命令从键盘读取变量值:
read: 用法:read [-ers] [-a 数组] [-d 分隔符] [-i 缓冲区文字] [-n 读取字符数] [-N 读取字符数] [-p 提示符] [-t 超时] [-u 文件描述符] [名称 ...]

                      1）read基本用法
                            执行后从会等待并接受用户输入（无任何提示的情况），并赋值给变量str：
                         read str
                         What's happen ?                          //随便输入一些文字，按Enter键提交
                         echo $str                                //查看赋值结果
                         What's happen ?

                            为了不至于使用户不知所措、莫名其妙，推荐的做法是结合-p选项给出友好提示：
                         read -p "请输入一个整数：" i
                                请输入一个整数：240
                         echo $i
                                240
                      2）stty终端显示控制
                                将回显功能关闭（stty -echo），
                                将回显功能恢复（stty echo）。
                                可参考下列操作创建一个测试脚本：
                         vim user.sh                                  //创建一个测试脚本
                         #!/bin/bash
                         read -p "请输入用户名:"  username               //读取用户名
                         stty -echo                                   //关闭回显
                         read -p "请输入密码:"  passwd                   //读取密码
                         stty echo                                    //恢复回显
                         echo ""                                      //恢复回显后补一个空行
                         useradd "$username"
                         echo "$passwd" | passwd --stdin "$username"
                         chmod +x user.sh          //添加执行权限
                               执行测试脚本user.sh，验证效果：
                         ./user.sh    
                                请输入用户名:  root                             //输入root，回车
                                请输入密码:                                               //输入1234567（不会显示），回车
使用export发布全局变量:

                               默认情况下，自定义的变量为局部变量，只在当前Shell环境中有效，而在子Shell环境中无法直接使用。

                               比如已定义的SCHOOL变量，当进入到sh或bash子Shell后，变量SCHOOL将处于未定义的状态：
                          yy="Tarena IT Group"
                          echo $yy
                          Tarena IT Group
                          bash                              //开启bash子进程
                          echo $yy                          //查看SCHOOL变量值无结果
                          exit                              //返回原有Shell环境
                          exit
                          echo $yy
                              若希望定义的变量能被子进程使用，可以使用export命令将其发布为全局变量。

                              使用export发布时，只需指定变量名（可以有多个）即可，也可以通过export命令直接设置新的全局变量：
                          export yy                              //发布已定义的变量
                          export XX="1234"                      //发布新变量
                                  验证刚刚发布的全局变量：
                           bash                                  //进入bash子Shell环境
                          echo $yy                              //查看全局变量的值 .. ..
                          Tarena IT Group
                          echo $XX
                                  1234




shell中各种括号的作用详解()、(())、[]、[[]]、{}:



                           一、小括号，圆括号（）
                               1、单小括号 ()
　　                                ①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。
                                      括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。

　　                                ②命令替换。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。
                                      有些shell不支持，如tcsh。
　    
                                  　③用于初始化数组。如：array=(a b c d)
                    
                               2、双小括号 (( ))
　　                               ①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，
                                     或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。
 
                               　　②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，
                                      输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)

                               　　③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6
　　 
                                   ④常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 
                                     只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i<5;i++)),如果不使用双括号, 则为for i in `seq 0 4`或者for i in {0..4}。
                                     再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。
                          
                           二、中括号，方括号[]

                               1、单中括号 []
　
                        　①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。
                           if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。
                                   这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。
                           if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。

                      　　②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。
                                   无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，
                                   如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。
　　
                                ③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
　　
                                ④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。
             
                              2、双中括号[[ ]]
　　
                                ①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。
                                 在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
 
                            　　②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串
                                 比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。

                          　 　③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，
                                 但是如果出现在[ ]结构中的话，会报错。
                                 比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。

                    　　 ④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

  
                        三、大括号、花括号 {}
 
                                 1、常规用法
　                                  　①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。

                                           第一种：对大括号中的以逗号分割的文件列表进行拓展。
                                                 如 touch {a,b}.txt 结果为a.txt b.txt。

                                           第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，
                                                 如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt

　　                                  ②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。
                                         与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。
                                        括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。

                               2、几种特殊的替换结构

                               ${var:-string}
                               ${var:+string}
                               ${var:=string}
                               ${var:?string}
　                            　
                                  ①${var:-string}和${var:=string}:
                                    若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；
                                    对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，
                                    用string替换${var:=string}的同时，把string赋给变量var： 
                            ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。

　　                              ② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，
                                    若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)

　　                              ③${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；
                                   若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。
　
                                 　补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。

                             3、四种模式匹配替换结构

                                   模式匹配记忆方法：
                                     # 是去掉左边(在键盘上#在$之左边)
                                     % 是去掉右边(在键盘上%在$之右边)
                                       #和%中的单一符号是最小匹配，两个相同符号是最大匹配。


                         ${var%pattern},${var%%pattern},${var#pattern},${var##pattern}

                              　　第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，
                                  如果是，就从命令行把variable中的内容去掉右边最短的匹配模式
　　
                                  第二种模式： ${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，
                                  如果是，就从命令行把variable中的内容去掉右边最长的匹配模式

                             　　 第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，
                                  如果是，就从命令行把variable中的内容去掉左边最短的匹配模式
　　
                                  第四种模式： ${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，
                                  如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
　　
                                  这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。
                                  结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。

                             # var=testcase 
                             # echo $var 
                               testcase 
                             # echo ${var%s*e} 
                               testca 
                             # echo $var 
                               testcase 
                             # echo ${var%%s*e} 
                               te 
                             # echo ${var#?e} 
                               stcase 
                             # echo ${var##?e} 
                                stcase 
                             # echo ${var##*e}
                             # echo ${var##*s} 
                               e 
                             # echo ${var##test} 
                               case
                              4、字符串提取和替换

 
                          ${var:num}
                          ${var:num1:num2}
                          ${var/pattern/pattern}
                          ${var//pattern/pattern}
　
                               　第一种模式：${var:num}，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。

                             　　第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。
　　 
                                 第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。
　
                               　第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。

                      
                               var=/home/centos 
                               echo $var 
                                   /home/centos
                               echo ${var:5} 
                                   /centos
                               echo ${var: -6} 
                                    centos 
                               echo ${var:(-6)} 
                                    centos 
                               echo ${var:1:4} 
                                    home 
                               echo ${var/o/h} 
                                    /hhme/centos
                               echo ${var//o/h}  
                                    /hhme/cenths
                         四、符号$后的括号
                        （1）${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。
                        （2）$(cmd) 命令替换，和`cmd`效果相同，结果为shell命令cmd的输，过某些Shell版本不支持$()形式的命令替换, 如tcsh。           
                        （3）$((expression)) 和`exprexpression`效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。
                         五、使用
                               1、多条命令执行
                               （1）单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。
                               （2）单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。
                           
                             对{}和()而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。




整数运算工具:

                            1）使用expr命令
                                乘法操作应采用 \* 转义，避免被作为Shell通配符；参与运算的整数值与运算操作符之间需要以空格分开，引用变量时必须加$符号。
                                首先定义变量X=1234，然后分别计算与78的加减乘除和求模运算结果：
                            X=1234                              //定义变量X
                            expr  $X  +  78                      //加法
                                    1312
                            expr  $X  -  78                       //减法
                                    1156
                            expr  $X  \*  78                      //乘法，操作符应添加\转义
                                    96252
                            expr  $X  /  78                      //除法，仅保留整除结果
                                    15
                            expr  $X  %  78                     //求模
                                    64
                            2）使用$[]或$(())表达式
                                   乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号；计算结果替换表达式本身，可结合echo命令输出。
                                   同样对于变量X=1234，分别计算与78的加减乘除和求模运算结果：
                            X=1234   
                           echo $[X+78]
                                    1312
                           echo $[X-78]
                                    1156
                           echo $[X*78]
                                    96252
                           echo $[X/78]
                                    15
                           echo $[X%78]
                                    64
                            3）使用let命令

                       expr或$[]、$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值
                              因此变量X=1234，在执行let运算后的值会变更；另外，let运算操作并不显示结果，但是可以结合echo命令来查看：
                           X=1234  
                           let y=X+22 
                           echo $y
                                   1256
                           let X++;  echo $X        # X++(X=X+1)
                           let X--;  echo $X        # X--(X=X-1)
                           let X+=78 ; echo $X        # X+=78(X=X+78)
                           let X-=78 ; echo $X     # X-=78(X=X-78)
                           let X*=78 ; echo $X     # X*=78(X=X*78)
                           let X/=78 ; echo $X     # X/=78(X=X/78)
                           let X%=78 ; echo $X     # X%=78(X=X%78)
                         小数运算工具:

                      1）bc交互式运算
                              先执行bc命令进入交互环境，然后再输入需要计算的表达式。以计算小数12.34与5.678的四则运算为例，相关操作如下：
                           bc 
                           bc 1.06.95
                          
                                   12.34+56.78                                        //加法
                                   69.12
                                   12.34-56.78                                        //减法
                                   -44.44
                                   12.34*56.78                                        //乘法
                                   700.66
                                   12.34/56.78                                        //除法
                                   0
                           quit                                              //退出交互计算器

                       2）bc非交互式运算
                                 将需要运算的表达式通过管道操作交给bc运算。注意，小数位的长度可采用scale=N限制，除此以外也受参与运算的数值的小数位影响。
                             以计算小数12.34与5.678的四则运算为例，相关操作如下：

                           echo 'scale=4;12.34+5.678' | bc
                                   18.018
                           echo 'scale=4;12.34*5.678' | bc 
                                   70.0665
                           echo 'scale=4;12.34/5.678' | bc 
                                   2.1733
                      条件测试操作:


                      条件测试的基本用法

                                  1）语法格式
                                     使用“test 表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。
                                     条件测试操作本身不显示出任何信息。测试的条件是否成立主要体现在命令执行后的返回状态（即 $?），
                                     所以可以在测试后查看变量$?的值来做出判断，或者结合&&、||等逻辑操作显示出结果（或作其他操作)。
       
                       字符串测试:

                                  1）== 比较两个字符串是否相同
                                     检查当前用户是否为root。
                                        当root用户执行时：
                                  [ $USER == "root" ]         //测试
                                   echo $?                    //查看结果0为对，非0为错
                                        当普通用户执行时：
                                  [ $USER == "root" ]
                                   echo $?                    //查看结果0为对，非0为错

                                  2）!= 比较两个字符串是否不相同
                                         当普通用户执行时：
                                  [ $USER != "root" ] 
                                         当root用户执行时：
                                  [ $USER != "root" ]

                                  3）一行执行多条命令的情况
                                 A && B                        //仅当A命令执行成功，才执行B命令
                                 A || B                        //仅当A命令执行失败，才执行B命令
                                 A ;  B                        //执行A命令后执行B命令，两者没有逻辑关系
                                 A && B || C                   //

                          4) -z 检查变量的值是否未设置（空值）
                                 var1="nb" ; var2=""
                                [ -z "$var1" ] && echo "空值" || echo "非空值"
                                          非空值
                                [ -z $var2 ] && echo "空值" || echo "非空值"
                                         空值                                      //变量var2已设置，但无任何值，视为空
                                [root@svr5 ~]# [ ! -z $var1 ]                //测试var1是否为非空
                                     还有一个-n可以测试变量是否不为空（相当于! -z）。

                           整数值比较

                                        参与比较的必须是整数（可以调用变量），比较非整数值时会出错：
                                A=20.4
                                [ $A -gt 10 ]                  //不支持小数比较
                                -bash: [: 20.4: integer expression expected
                         1）-eq 比较两个数是否相等。
                                X=20                          //定义一个测试变量
                                [ $X -eq 20 ] && echo "相等" || echo "不相等"
                                         相等
                                [ $X -eq 30 ] && echo "相等" || echo "不相等"
                                         不相等
                         2) -ne 比较两个数是否不相等。
                                 X=20                          //定义一个测试变量
                                [ $X -ne 20 ] && echo "不等于" || echo "等于"
                                         等于
                                [ $X -ne 30 ] && echo "不等于" || echo "等于"
                                         不等于
                         3）-gt 比较前面的整数是否大于后面的整数。
                                 X=20                          //定义一个测试变量
                                [ $X -gt 10 ] && echo "大于" || echo "否"
                                         大于
                                [ $X -gt 20 ] && echo "大于" || echo "否"
                                          否
                                [ $X -gt 30 ] && echo "大于" || echo "否"
                                          否
                         4）-ge 比较前面的整数是否大于或等于后面的整数。
                                 X=20                          //定义一个测试变量
                                [ $X -ge 10 ] && echo "大于或等于" || echo "否"
                                         大于或等于
                                [ $X -ge 20 ] && echo "大于或等于" || echo "否"
                                         大于或等于
                                [ $X -ge 30 ] && echo "大于或等于" || echo "否"
                                         否
                         5）-lt 比较前面的整数是否小于后面的整数。
                                X=20                          //定义一个测试变量
                                [ $X -lt 10 ] && echo "小于" || echo "否"
                                         否
                                [ $X -lt 20 ] && echo "小于" || echo "否"
                                         否
                                [ $X -lt 30 ] && echo "小于" || echo "否"
                                         小于
                         6）-le 比较前面的整数是否小于或等于后面的整数。
                                X=20                          //定义一个测试变量
                                [ $X -le 10 ] && echo "小于或等于" || echo "否"
                                         否
                                [ $X -le 20 ] && echo "小于或等于" || echo "否"
                                         小于或等于
                                [ $X -le 30 ] && echo "小于或等于" || echo "否"
                                         否
                                7）提取当前登录的用户数，比较是否大于等于3。
                                who | wc -l                                  //确认已登录的用户数
                                           2
                                N=$(who | wc -l)                              //赋值给变量N
                                [ $N -ge 3 ] && echo "超过了" || echo "没超过"
                                          没超过
                                        上述赋值给变量N及与3比较的操作，可以简化为如下形式：
                                [ $(who | wc -l) -ge 3 ] && echo "超过了" || echo "没超过"
                                          没超过
                       识别文件/目录的状态：

 
                         1）-e 判断对象是否存在（不管是目录还是文件）
                                [ -e "/usr/" ] && echo "存在" || echo "不存在"
                                          存在
                                [ -e "/etc/fstab" ] && echo "存在" || echo "不存在"
                                          存在
                                [ -e "/home/nooby" ] && echo "存在" || echo "不存在"
                                          不存在
                         2）-d 判断对象是否为目录（存在且是目录）
                                [ -d "/usr/" ] && echo "是目录" || echo "不是目录"
                                          是目录
                                [ -d "/etc/fstab" ] && echo "是目录" || echo "不是目录"
                                          不是目录
                                [ -d "/home/nooby" ] && echo "是目录" || echo "不是目录"
                                          不是目录
                         3）-f 判断对象是否为文件（存在且是文件）
                                [ -f "/usr/" ] && echo "是文件" || echo "不是文件"
                                          不是文件
                                [ -f "/etc/fstab" ] && echo "是文件" || echo "不是文件"
                                          是文件
                                [ -f "/home/nooby" ] && echo "是文件" || echo "不是文件"
                                         不是文件

                         4）-r 判断对象是否可读
                                        注：此测试对root用户无效，无论文件是否设置r权限，root都可读：
                                cp /etc/hosts /tmp/test.txt                                 //复制一个文件做测试
                                chmod -r /tmp/test.txt                                      //去掉所有的r权限
                                [ -r "/tmp/test.txt" ] && echo "可读" || echo "不可读"
                                          可读                                                                        //root测试结果仍然可读
                                          切换为普通用户，再执行相同的测试，结果变为“不可读”：
                                [ -r "/tmp/test.txt" ] && echo "可读" || echo "不可读"
                                          不可读
                      
                         5）-w 判断对象是否可写
                                        注：此测试同样对root用户无效，无论文件是否设置w权限，root都可写：
                                 chmod -w /tmp/test.txt                                     //去掉所有的w权限
                                 ls -l /tmp/test.txt                                        //确认设置结果
                                 ---------- 1 root root 33139 12-11 10:43 /tmp/test.txt
                                 [ -w "/tmp/test.txt" ] && echo "可写" || echo "不可写"
                                            可写
                                          切换为普通用户，可以正常使用-w测试：
                                 ls -l /tmp/test.txt
                                  ---------- 1 root root 33139 12-11 10:52 /tmp/test.txt
                                 [ -w "/tmp/test.txt" ] && echo "可写" || echo "不可写"
                                            不可写

                         6）-x 判断对象是否具有可执行权限
                                        注：这个取决于文件本身、文件系统级的控制，root或普通用户都适用：
                                 chmod 644 /tmp/test.txt                                     //重设权限，无x
                                 ls -l /tmp/test.txt                                         //确认设置结果
                                 -rw-r--r-- 1 root root 33139 12-11 10:52 /tmp/test.txt
                                 [ -x "/tmp/test.txt" ] && echo "可执行" || echo "不可执行"
                                          不可执行
                                 chmod +x /tmp/test.txt                                      //添加x权限
                                 [ -x "/tmp/test.txt" ] && echo "可执行" || echo "不可执行"
                                          可执行
                      多个条件/操作的逻辑组合:

                               1）&&，逻辑与
                                       给定条件必须都成立，整个测试结果才为真。
                                        检查变量X的值是否大于10，且小于30：
                               X=20                      //设置X变量的值为20
                               [ $X -gt 10 ] && [ $X -lt 30 ] && echo "YES"
                               YES
                 
                               2）||，逻辑或
                                      只要其中一个条件成立，则整个测试结果为真。
                                      只要/tmp/、/var/spool/目录中有一个可写，则条件成立：
                              [ -w "/tmp/" ] || [ -w "/var/spool/" ] && echo "OK"
                              OK

                    3 案例3：使用if选择结构
 

                          if单分支的语法组成：
                               if  条件测试
                               then  命令序列
                               fi
                               if双分支的语法组成：
                               if  条件测试
                               then
                                        命令序列1
                               else  
                                        命令序列2
                               fi

                          if多分支的语法组成：
                               if    条件测试1 ;then  
                                        命令序列1
                               elif  条件测试2 ;then  
                                        命令序列2
                               else
                                        命令序列n
                               fi
 
              检测/media/cdrom目录，若不存在则创建

                              vim mountdir.sh 
                              #!/bin/bash
                              dir="/media/cdrom/"
                              if [ ! -d $dir ]
                              then
                                 mkdir -p $dir
                              fi 
                              chmod +x mountdir.sh                  //添加可执行权限

                           2）测试、验证脚本功能
                              ls -ld /media/cdrom                  //本来没有/media/cdrom目录
                              ls: /media/cdrom: 没有那个文件或目录
                              ./mountdir.sh                          //执行脚本
                              ls -ld /media/cdrom                  //再检查已经有了
                               drwxr-xr-x 2 root root 4096 12-11 15:16 /media/cdrom
                                       有了/media/cdrom文件夹以后，再次执行上述脚本，实际上不做任何有效操作：
                              ./mountdir.sh
                        检测并判断指定的主机是否可ping通


                        为了节省ping测试时间，可以只发送3个测试包（-c 3）、缩短发送测试包的间隔秒数（-i 0.2）、等待反馈的超时秒数（-W 1）。比如，检查可ping通的主机：
                         ping -c 3 -i 0.2 -W 1 192.168.4.5
                                //执行状态表示成功

                           2）脚本编写参考如下：
                         vim pinghost.sh 
                         #!/bin/bash
                         ping -c 3 -i 0.2 -W 1 $1 &> /dev/null
                         if [ $? -eq 0 ] ; then
                             echo "Host $1 is up."
                         else
                         echo "Host $1 is down."
                         fi


                  使用for循环结构:

                        在Shell脚本应用中，常见的for循环采用遍历式、列表式的执行流程，通过指定变量从值列表中循环赋值，每次复制后执行固定的一组操作。

                                 for循环的语法结构如下所示：
                                             
                                    for  变量名  in  值列表
                                    do
                                                    命令序列
                                    done

                                    for  变量名  in  `ls /etc/*.conf`
                                    do
                                              命令序列
                                     done

                                    for  变量名  in  {1..5}
                                    do
                                                    命令序列
                                    done
              
                                    for  变量名  in  `seq 5`
                                    do
                                                    命令序列
                                    done
 
                                        通过循环批量显示5个hello world：
                                      vim for01.sh
                                      #!/bin/bash
                                       for i in 1 2 3 4 5
                                       do
                                            echo "hello world"
                                       done
                                       chmod +x for01.sh
                                       ./for01.sh
                                       
                                        通过循环批量显示10个hello world：
                                       vim for02.sh
                                       #!/bin/bash
                                       for i in {1..10}
                                       do
                                             echo "hello world"
                                       done

                                        批量检测多个主机的存活状态

                                                1）编写脚本如下：
                                                   命令备注：ping命令可以测试某台主机的连通性，
                                                    使用-c选项可以设置ping的次数，
                                                    使用-i选项可以设置多次ping之间的间隔时间（单位秒），
                                                    使用-W选项可以设置ping不通时的超时时间（单位秒）。
                                      vim chkhosts.sh
                                      #!/bin/bash
                                      for i in {1..254}
                                      do
                                                 ping -c 3 -i 0.2 -W 1 192.168.4.$i &> /dev/null
                                                 if [ $? -eq 0 ] ; then
                                                 echo "Host 192.168.4.$i is up."
                                                 else
                                                 echo "Host 192.168.4.$i is down."
                                                 fi

                                        附加扩展知识（C语言风格的for循环语法格式）
                      
                                       vim cfor.sh
                                       #!/bin/bash
                                       for ((i=1;i<=5;i++))
                                       do
                                               echoi $i
                                       done
            
                        使用while循环结构:
 

                               while循环属于条件式的执行流程，会反复判断指定的测试条件，只要条件成立即执行固定的一组操作，直到条件变化为不成立为止。
                                       所以while循环的条件一般通过变量来进行控制，在循环体内对变量值做相应改变，以便在适当的时候退出，避免陷入死循环。
             
                              while循环的语法结构如下所示：
                                  while  条件测试
                                  do
                                                  命令序列
                                  done

                                  while :
                                  do
                                                  命令序列
                                  done


                        while循环基本用法

                                     脚本1，无心的死循环脚本：
                                   vim while01.sh
                                   #!/bin/bash
                                   i=1
                                   while [ $i -le 5 ]
                                   do
                                        echo "$i"
                                   done
                                   chmod +x while01.sh
                                   ./while01.sh                //死循环，需要使用Ctrl+C终止脚本

                                    脚本2，有效循环脚本：
                                   vim while02.sh
                                   #!/bin/bash
                                    i=1
                                    while [ $i -le 5 ]
                                    do
                                          echo "$i"
                                          let i++
                                    done

                                    脚本3，死循环的一般格式：
                                  vim while03.sh
                                  #!/bin/bash
                                  while :
                                  do
                                        echo "hello world"
                                  done


                            检测192.168.4.0/24网段，列出不在线的主机地址:
     

                                  vim chknet.sh
                                  #!/bin/bash
                                  i=1
                                   while [ $i -le 254 ]
                                   do
                                   IP="192.168.4.$i"
                                   ping -c 3 -i 0.2 -W 1 $IP &> /dev/null
                                   if [ $? -eq 0 ] ; then
                                           echo "Host $IP is up."
                                   else
                                            echo "Host $IP is down."
                                   fi
                                   let i++
                                   done

                                 
                           基于case分支编写脚本:

                         case分支属于匹配执行的方式，它针对指定的变量预先设置一个可能的取值，判断该变量的实际取值是否与预设的某一个值相匹配，
                                如果匹配上了，就执行相应的一组操作，如果没有任何值能够匹配，就执行预先设置的默认操作。
                  
                                  case分支的语法结构如下所示：
                                          case  变量  in
                                                      模式1)
                                                        命令序列1 ;;
                                                      模式2)
                                                        命令序列2 ;;
                                                         .. ..
                                                      *)
                                                         默认命令序列
                                          esac

                                      vim test.sh
                                      #!/bin/bash
                                       case $1 in
                                       redhat)
                                           echo "fedora";;
                                       fedora)
                                           echo "redhat";;
                                                  *)                                              //默认输出脚本用法
                                           echo "用法: $0 {redhat|fedora}"
                                       esac

 
                                  使用Shell函数

                                  在Shell脚本中，将一些需重复使用的操作，定义为公共的语句块，即可称为函数。通过使用函数，可以使脚本代码更加简洁，增强易读性，提高Shell脚本的执行效率

                                   1）函数的定义方法
                                     格式1：
                                function  函数名 {
                                                  命令序列
                                                   .. ..
                                                 }
                                     格式2：
                                                    函数名() {
                                                  命令序列
                                                   .. ..
                                                }
                                   2）函数的调用
                                     直接使用“函数名”的形式调用，如果该函数能够处理位置参数，则可以使用“函数名 参数1 参数2 .. ..”的形式调用。
                                     注意：函数的定义语句必须出现在调用之前，否则无法执行。
                                    3) 测试语法格式
                                mycd(){                        //定义函数
                                > mkdir /test
                                > cd /test
                                         > }
                                mycd                            //调用函数
                                mycd(){                        //定义函数
                                > mkdir $1
                                > cd $1
                                         > }
                                mycd  /abc                            //调用函数
                                mycd  /360                            //调用函数


                         编写mycolor.sh脚本:
                                  #!/bin/bash
                                    #下面是字体输出颜色及终端格式控制
                                    #字体色范围：30-37

                                  echo -e "\033[30m 黑色字 \033[0m"
                                  echo -e "\033[31m 红色字 \033[0m"
                                  echo -e "\033[32m 绿色字 \033[0m"
                                  echo -e "\033[33m 黄色字 \033[0m"
                                  echo -e "\033[34m 蓝色字 \033[0m"
                                  echo -e "\033[35m 紫色字 \033[0m"
                                  echo -e "\033[36m 天蓝字 \033[0m"
                                  echo -e "\033[37m 白色字 \033[0m"
  
                                    #字背景颜色范围：40-47

                                  echo -e "\033[40;37m 黑底白字 \033[0m"
                                  echo -e "\033[41;30m 红底黑字 \033[0m"
                                  echo -e "\033[42;34m 绿底蓝字 \033[0m"
                                  echo -e "\033[43;34m 黄底蓝字 \033[0m"
                                  echo -e "\033[44;30m 蓝底黑字 \033[0m"
                                  echo -e "\033[45;30m 紫底黑字 \033[0m"
                                  echo -e "\033[46;30m 天蓝底黑字 \033[0m"
                                  echo -e "\033[47;34m 白底蓝字 \033[0m"

                                   #控制选项说明

                                  #\033[0m 关闭所有属性
                                  #\033[1m 设置高亮度
                                  #\033[4m 下划线
                                  echo -e "\033[4;31m 下划线红字 \033[0m"
                                            #闪烁
                                  echo -e "\033[5;34m 红字在闪烁 \033[0m"
                                            #反影
                                  echo -e "\033[8m 消隐 \033[0m "

                                  #\033[30m-\033[37m 设置前景色
                                  #\033[40m-\033[47m 设置背景色
                                  #\033[nA光标上移n行
                                  #\033[nB光标下移n行
                                  echo -e "\034[4A 光标上移4行 \033[0m"
                                  #\033[nC光标右移n行
                                  #\033[nD光标左移n行
                                  #\033[y;xH设置光标位置
                                  #\033[2J清屏
                                  #\033[K清除从光标到行尾的内容
                                    echo -e "\033[K 清除光标到行尾的内容 \033[0m"
                                  #\033[s 保存光标位置
                                  #\033[u 恢复光标位置
                                            #\033[?25| 隐藏光标
                                  #\033[?25h 显示光标
                                    echo -e "\033[?25l 隐藏光标 \033[0m"
                                    echo -e "\033[?25h 显示光标 \033[0m"

                                 1）任务需求及思路分析
                                          用户在执行时提供2个整数参数，这个可以通过位置变量$1、$2读入。

                                2）根据实现思路编写脚本文件

                                 vim mycolor.sh
                                 #!/bin/bash
                                 cecho() {
                                 echo –e "\033[$1m$2\033[0m"
                                          }
                                 cecho 32 OK
                                 cecho 33 OK
                                 cecho 34 OK
                                 cecho 35 OK

                                 chmod +x mycolor.sh
                                 3）测试脚本执行效果
                                 ./mycolor.sh
          
              Shell版本的fork炸弹
                             vim test.sh
                             #!/bin/bash
                                     .(){
                                     .|.&
                                     }
                                     .
                        

                 中断及退出：

                                   通过break、continue、exit在Shell脚本中实现中断与退出的功能。
 
                            break可以结束整个循环；
                            continue结束本次循环，进入下一次循环；
                            exit结束整个脚本，案例如下：
                           
                            vim  test.sh
                            #!/bin/bash
                            for  i   in   {1..5}
                            do
                                [  $i  -eq  3 ]&& break //这里将break替换为continue，exit分别测试脚本执行效果       echo $i
                            done
                            echo "Game Over"







                  字符串截取及切割:

                                    子串截取的三种用法：

                                    ${变量名:起始位置:长度}

                            expr substr "$变量名" 起始位置 长度

                            echo $变量名 | cut -b 起始位置-结束位置

                  子串替换的两种用法：

                                    只替换第一个匹配结果：${变量名/old/new}

                                    替换全部匹配结果：${变量名//old/new}

                      字符串掐头去尾：
 
                                     从左向右，最短匹配删除：${变量名#*关键词}
                                     从左向右，最长匹配删除：${变量名##*关键词}
                                     从右向左，最短匹配删除：${变量名%关键词*}
                                     从右向左，最长匹配删除：${变量名%%关键词*}
                           

                        字符串的截取：

                                     1）方法一，使用 ${}表达式
                                           格式：${变量名:起始位置:长度}
                                           使用${}方式截取字符串时，起始位置是从0开始的。

                                          定义一个变量phone，并确认其字符串长度：
                                     
                                     phone="13788768897"
                                     echo ${#phone}
                                                11                                         //包括11个字符
    
                                使用${}截取时，起始位置可以省略，省略时从第一个字符开始截。

                                     比如，以下操作都可以从左侧开始截取前6个字符：
                                  
                                      echo ${phone:0:6}
                                                 137887
                     
                                      echo ${phone::6}
                                                 137887

                                     因此，如果从起始位置1开始截取6个字符，那就变成这个样子了：
                               
                                      echo ${phone:1:6}
                                                 378876

                                     2）方法二，使用 expr substr

                                   格式：expr substr "$变量名" 起始位置 长度

                                       还以前面的phone变量为例，确认原始值：
                                 
                                  echo $phone
                                            13788768897

                                       使用expr substr截取字符串时，起始编号从1开始，这个要注意与${}相区分。
                                       从左侧截取phone变量的前6个字符：
                              
                                  expr substr "$phone" 1 6
                                            137887
                                       从左侧截取phone变量，从第9个字符开始，截取3个字符：
                                  expr substr "$phone" 9 3
                                            897

                                       3）方式三，使用cut分割工具
                                          格式：echo $变量名 | cut -b 起始位置-结束位置
                                          选项 -b 表示按字节截取字符，其中起始位置、结束位置都可以省略。
                                          当省略起始位置时，视为从第1个字符开始，当省略结束位置时，视为截取到最后。
                                      
                            还以前面的Phone变量为例，确认原始值：                  
                                  
                                 echo $phone
                                           13788768897

                                       从左侧截取前6个字符，可执行以下操作：
                                 echo $phone | cut -b 1-6
                                           137887
                                       从第8个字符截取到末尾：
                                 echo $phone | cut -b 8-
                                           8897
                                       只截取单个字符，比如第9个字符：
                                 echo $phone | cut -b 9
                                           8
                                       截取不连续的字符，比如第3、5、8个字符：
                                 echo $phone | cut -b 3,5,8
                                           788
              
                     4）一个随机密码的案例

                           版本1：
                 
                             vim rand.sh
                             #!/bin/bash
                             x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
                                     //所有密码的可能性是26+26+10=62（0-61是62个数字）
                             num=$[RANDOM%62]
                             pass=${x:num:1}
                          
                           版本2：
                             
                             vim rand.sh
                             #!/bin/bash
                             x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
                                     //所有密码的可能性是26+26+10=62（0-61是62个数字）
                             pass=''
                             for i in {1..8}
                             do
                                 num=$[RANDOM%62]
                                 tmp=${x:num:1}
                                 pass=${pass}$tmp
                             done
                             echo $pass
 
                      urandom版本：

                              #!/bin/bash
                              tr -dc '_A-Za-z0-9'  </dev/urandom | head -c  10

                      uuid版本:
                                      
                              uuidgen
                              ed1fdb83-72bb-4e85-88b2-a8f427686860

                        字符串的替换

                                    1）只替换第1个子串
                                       格式：${变量名/old/new}
                                       还以前面的phone变量为例，确认原始值：
 
                               echo $phone
                                        13788768897
                                       
                       将字符串中的第1个8替换为X:
                               echo  ${phone/8/X}
                               137X8768897

                                   2）替换全部子串

                                        格式：${变量名//old/new}
                 
                       将phone字符串中的所有8都替换为X:
                               echo  ${phone//8/X}
                               137XX76XX97

                       字符串的匹配删除:

                                        以处理系统默认的账户信息为例，定义变量A：
                               A=`head -1 /etc/passwd`
                               echo $A
                               root:x:0:0:root:/root:/bin/bash

                                   1）从左向右，最短匹配删除
                      
                                       格式：${变量名#*关键词}

                      删除从左侧第1个字符到最近的关键词“：”的部分，* 作通配符理解：

                               echo ${A#*:}
                               x:0:0:root:/root:/bin/bash

                                   2）从左向右，最长匹配删除

                                       格式：${变量名##*关键词}

                      删除从左侧第1个字符到最远的关键词“:”的部分：

                               echo $A                      //确认变量A的值
                               root:x:0:0:root:/root:/bin/bash
                               echo ${A##*:}
                               /bin/bash

                                   3）从右向左，最短匹配删除
                                       格式：${变量名%关键词*}
                      
                      删除从右侧最后1个字符到往左最近的关键词“:”的部分，* 做通配符理解：

                               echo ${A%:*}
                               root:x:0:0:root:/root

                                   4）从右向左，最长匹配删除

                                        格式：${变量名%%关键词*}
     
                      删除从右侧最后1个字符到往左最远的关键词“:”的部分：

                               echo ${A%%:*}
                               root

                      批量修改文件扩展名的脚本:
 
                      脚本用途为：批量修改当前目录下的文件扩展名，将.doc改为.txt。
                      脚本内容参考如下：
                               vim renfile.sh
                               #!/bin/bash
                               for i in `ls *.$1`            #注意这里有反引号
                               do
                                      mv $i  ${i%.*}.$2
                               done



                           4)几种特殊的替换结构

                               ${var:-string}
                               ${var:+string}
                               ${var:=string}
                               ${var:?string}
　                            　
                                  ①${var:-string}和${var:=string}:
                                    若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；
                                    对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，
                                    用string替换${var:=string}的同时，把string赋给变量var： 
                            ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。

　　                              ② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，
                                    若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)

　　                              ③${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；
                                   若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。
　
                                 　补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。


                    expect预期交互:

                                   实现SSH登录的自动交互：
                                   提前准备好目标主机，IP地址为192.168.4.5
                                   执行脚本后自动登入，并且在目标主机建立测试文件 /tmp/mike.txt


                    expect可以为交互式过程（比如FTP、SSH等登录过程）自动输送预先准备的文本或指令，而无需人工干预。
                                   触发的依据是预期会出现的特征提示文本。
                                   储备知识（发送邮件的几种方式）： 
                                  echo "test mail" | mail -s test root
                                  mail -s test root < /etc/passwd
                                  mail -s test root << EOF
                                  test mail
                                  hell world
                                  EOF


                    实现此案例需要按照如下步骤进行。
                              准备expect及SSH测试环境:

                                (1) 安装expect工具
                            yum  -y  install  expect                  //安装expect
                                    .. ..
                         Installed:
                         expect.x86_64 0:5.44.1.15-5.el6_4                                                            
                         Dependency Installed:
                         tcl.x86_64 1:8.5.7-6.el6  
                         which expect                              //确认expect路径
                         /usr/bin/expect

                                (2) 编写脚本，实现免交互登录

                         vim  expect_ssh.sh 
                         #!/bin/bash                            
                         expect << EOF
                         spawn ssh -o StrictHostKeyChecking=no 192.168.4.5                               #//创建交互式进程
                         expect "password:" { send "123456\r" }              #//自动发送密码
                         expect "#"          { send "touch /tmp.txt\r" }     #//发送命令
                         expect "#"          { send "exit\r" }
                         EOF
                         通过循环批量操作，版本2：
                                注意：不要照抄脚本里的IP地址与密码，需要根据自己的实际情况填写！！！
                         vim  expect_ssh.sh 
                         #!/bin/bash
                         for i in 10 11                                        #注意IP根据实际情况填写
                         do
                         expect << EOF
                         spawn ssh 192.168.4.$i                               #//创建交互式进程
                         expect "password:" { send "123456\r" }              #//自动发送密码
                         expect "#"          { send "touch /tmp.txt\r" }      #//发送命令
                         expect "#"          { send "exit\r" }
                         EOF
                         done

                        注意事项：
                         expect脚本的最后一行默认不执行
                                如果不希望ssh时出现yes/no的提示，远程时使用如下选项:
                         # ssh -o StrictHostKeyChecking=no server0

                      正则表达式:


                             基本正则列表
                                 ^                  匹配行首

                                 $                  匹配行尾

                                 [ ]                 集合，匹配括号内任意单个字符

                                 [^ ]                对集合取反         

                                 .                  匹配任意单个字符

                                 *                  匹配前一个字符出现任意次数（不允许单独使用）

                          \{n,m\}        匹配前一个字符出现n到m次

                          \{n\}          匹配前一个字符出现n次

                          \{n,\}         匹配前一个字符出现n次以上

                                  \{\}               保留




                             扩展正则列表 
                                    +                 最少匹配一次

                                    ？                 最多匹配一次
            
                            {n,m}          匹配n到m次

                                    ()                 组合为整体，保留
       
                                     |                  或者

                            \b             单词边界

  
                        正则表达式匹配练习：

                         1）典型的应用场合：grep、egrep检索文本行
                            使用不带-E选项的grep命令时，支持基本正则匹配模式。

                      grep '^r' /etc/passwd
                      root:x:0:0:root:/root:/bin/bash
                      rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
                      rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin

                     输出以“localhost”结尾的行：

                      grep 'localhost$' /etc/hosts
                      127.0.0.1               localhost.localdomain localhost

                     若希望在grep检索式同时组合多个条件，比如输出以“root”或者以“daemon”开头的行，这时候基本正则就不太方便了（“或者”必须转义为“\|”）：
                      grep '^root|^daemon' /etc/passwd          //搜索无结果

                      grep '^root\|^daemon' /etc/passwd          //正确获得结果
                      root:x:0:0:root:/root:/bin/bash
                      daemon:x:2:2:daemon:/sbin:/sbin/nologin

                      而若若使用grep -E或egrep命令，可支持扩展正则匹配模式，能够自动识别 |、{ 等正则表达式中的特殊字符，用起来更加方便，比如：

                      grep -E '^root|^daemon' /etc/passwd
                      root:x:0:0:root:/root:/bin/bash
                      daemon:x:2:2:daemon:/sbin:/sbin/nologin
                            或者
                      egrep '^root|^daemon' /etc/passwd
                      root:x:0:0:root:/root:/bin/bash
                      daemon:x:2:2:daemon:/sbin:/sbin/nologin
   
                      使用grep -E 与 使用egrep命令完全等效，推荐使用后者，特别是涉及到复杂的正则表达式的时候。

                     2）grep、egrep命令的-q选项
                              选项 -q 表示 quiet（静默）的意思，结合此选项可以只做检索而并不输出，通常在脚本内用来识别查找的目标是否存在，
                              通过返回状态 $? 来判断，这样可以忽略无关的文本信息，简化脚本输出。
 
                                    比如，检查/etc/hosts文件内是否存在192.168.4.4的映射记录，如果存在则显示“YES”，否则输出“NO”，一般会执行：
                            grep '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
                            192.168.4.4     svr5.tarena.com svr5
                            YES

                              这样grep的输出信息和脚本判断后的提示混杂在一起，用户不易辨别，所以可以改成以下操作：
                       
                            grep -q '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
                            YES

                          3）基本元字符 ^、$ —— 匹配行首、行尾
                                   
                                    输出默认运行级别的配置记录（以id开头的行）：
 
                            egrep '^id' /etc/inittab
                            id:3:initdefault:
                                    
                                    输出主机名配置记录（以HOSTNAME开头的行）：
                                
                            egrep '^HOSTNAME' /etc/sysconfig/network

                            HOSTNAME=svr5.tarena.com
                                       
                                   统计本地用户中登录Shell为“/sbin/nologin”的用户个数：
                           
                            egrep -m10 '/sbin/nologin$' /etc/passwd  //先确认匹配正确
                                          
                            egrep -c '/sbin/nologin$' /etc/passwd
                                    32                                      //结合 -c 选项输出匹配的行数
 
                                   使用 -c 选项可输出匹配行数，这与通过管道再 wc -l的效果是相同的，但是写法更简便。比如，统计使用“/bin/bash”作为登录Shell的正常用户个数，可执行：


                        4）基本元字符 . —— 匹配任意单个字符
 
                                   以/etc/rc.local文件为例，确认文本内容：
                            egrep '.' /etc/rc.local
                            #!/bin/sh
                                    #
                            # This script will be executed *after* all the other init scripts.
                            # You can put your own initialization stuff in here if you don't
                         # want to do the full Sys V style init stuff.
                              touch /var/lock/subsys/local
、
                                  （用 –v 选项将条件取反）：
                            egrep -v '.' /etc/rc.local

                                   上述取空行的操作与下列操作效果相同：


                        5）基本元字符 +、?、* —— 目标出现的次数

                                 

                                   输出包括 f、ff、ff、……的行，即“f”至少出现一次：
                          
                           egrep 'f+' /etc/rc.local
  
                                   输出/etc/passwd文件内“r”开头且以“nologin”结尾的用户记录，即中间可以是任意字符：
                        
                           egrep '^r.*nologin$' /etc/passwd

                        6）元字符 {} —— 限定出现的次数范围

                                   输出包括ababab的行，即“ab”连续出现3次：

                           egrep '(ab){3}' brace.txt

                                   输出包括ababab、abababab、……的行，即“ab”最少连续出现3次：
             
                           egrep '(ab){3,}' brace.txt

                         7）元字符 [] —— 匹配范围内的单个字符

                                    输出包括abc、abd的行，即前两个字符为“ab”，第三个字符只要是c、d中的一个就符合条件：

                            egrep 'ab[cd]' brace.txt

                                    输出包括大写字母的行，使用[A-Z]匹配连续范围：

                            egrep '[A-Z]' brace.txt

                                    输出包括“非空格也非小写字母”的其他字符的行，本例中大写字母和 – 符合要求：
    
                            egrep '[^ a-zA-Z]' brace.txt

                         8）单词边界匹配

                                    输出包括单词“init”的行，文件中“initialization”不合要求：
                              
                            egrep '\binit\b' /etc/rc.local

                                    或者：
 
                            egrep '\<init\>' /etc/rc.local

                                    输出包括以“ll”结尾的单词的行，使用 \> 匹配单词右边界：

                            egrep 'll\>' /etc/rc.local

                                    或者：

                            egrep 'll\b' /etc/rc.local

                         9）多个条件的组合

                                   通过dmesg启动日志查看蓝牙设备、网卡设备相关的信息：

                           egrep -i 'eth|network|bluetooth' /var/log/dmesg



sed基本用法


                   sed文本处理工具的用法：
 
                                  用法1：前置命令 | sed  [选项]  '条件指令'
                                  用法2：sed  [选项]  '条件指令'  文件.. ..

                                  相关说明如下：
                                  条件可以是行号或者/正则/
                                  没有条件时，默认为所有条件
                                  指令可以是增、删、改、查等指令
                                  默认sed会将所有输出的内容都打印出来，可以使用-n屏蔽默认输出
                                  选项中可以使用-r选项，让sed支持扩展正则

                       认识sed工具的基本选项 :

                          sed命令的常用选项如下：
                          -n（屏蔽默认输出，默认sed会输出读取文档的全部内容）
                          -r（让sed支持扩展正则）
                          -i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）

                     1）sed命令的 -n 选项
                              执行p打印等过滤操作时，希望看到的是符合条件的文本。但不使用任何选项时，默认会将原始文本一并输出，从而干扰过滤效果。
                       
                              比如，尝试用sed输出/etc/hosts的第1行：

                           sed '1p' /etc/hosts
                             127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
                             127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
                             ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

                              可以发现所有的行都被显示出来了（第1行重复2次）。—— 正确的用法应该添加 -n 选项，这样就可以只显示第1行了：

                           sed -n '1p' /etc/hosts
                             127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4

                              行号可以是连续的行号，如打印passwd第3到第6行账户的信息：

                             sed  -n '3,6p' /etc/passwd
 
                     2）sed命令的 -i 选项
                              正常情况下，sed命令所做的处理只是把操作结果（包括打印、删除等）输出到当前终端屏幕，而并不会对原始文件做任何更改：

                             sed 'd' /etc/passwd                      //删除所有行
                             cat /etc/passwd                          //查看原始文本，并未改动

                              若希望直接修改文件内容，应添加选项 -i 。
                              比如，直接删除test.txt（自行创建一个任意内容的文件）的第1~4行：

                             sed -i '1,4d' test.txt            //删除操作
                             cat test.txt                      //确认删除结果
                         
                          3）多个指令可以使用分号隔离
                               
                              用分号来隔离多个操作，比如：
                             sed -n '1p;4p' /etc/passwd
                             root:x:0:0:root:/root:/bin/bash
                             adm:x:3:4:adm:/var/adm:/sbin/nologin


                   认识sed工具的条件:

                             sed [选项] '条件指令' 文件.. ..
                             sed命令可以使用行号或正则做为条件匹配：
                            1）行号案例
                                       打印第3行：
                              sed -n '3p' /etc/passwd

                                       打印第3到5行：
                              sed -n '3,5p' /etc/passwd

                                       打印第3和5行：
                              sed -n '3p;5p' /etc/passwd

                                       打印第3以及后面的10行：
                              sed -n '3,+10p' /etc/passwd

                                       打印奇数行：
                              sed -n '1~2p' /etc/passwd

                                       打印偶数行：
                              sed -n '2~2p' /etc/passwd

                           2）正则案例
                                       打印包含root的行：
                               sed -n '/root/p' /etc/passwd

                                       打印bash结尾的行：
                               sed -n '/bash$/p' /etc/passwd

                           3）没有条件，则表示匹配所有行
                               sed -n 'p' /etc/passwd
                
               sed工具的p、d、s操作指令案例集合:

                            1）下面看看sed工具的p指令案例集锦（自己提前生成一个a.txt文件）

                            sed  -n 'p' a.txt                              //输出所有行，等同于cat a.txt
                            sed  -n '4p' a.txt                             //输出第4行
                            sed  -n '4,7p' a.txt                           //输出第4~7行
                            sed  -n '4,+10p' a.txt                         //输出第4行及其后的10行内容
                            sed  -n '/^bin/p' a.txt                        //输出以bin开头的行
                            sed  -n '$=' a.txt                             //输出文件的行数

                           2）下面看看sed工具的d指令案例集锦（自己提前生成一个a.txt文件）
                        
                            sed  '3,5d' a.txt                              //删除第3~5行
                            sed  '/xml/d' a.txt                            //删除所有包含xml的行
                            sed  '/xml/!d' a.txt                           //删除不包含xml的行，!符号表示取反
                            sed  '/^install/d' a.txt                       //删除以install开头的行
                            sed  '$d' a.txt                                //删除文件的最后一行
                            sed  '/^$/d' a.txt                             //删除所有空行

                     3）sed命令的s替换基本功能（s/旧内容/新内容/选项）：

                                    注意：替换操作的分隔“/”可改用其他字符，如#、&等，便于修改文件路径
                      
                            sed 's/xml/XML/'  a.txt        //将每行中第一个xml替换为XML
                            sed 's/xml/XML/3' a.txt     //将每行中的第3个xml替换为XML
                            sed 's/xml/XML/g' a.txt     //将所有的xml都替换为XML
                            sed 's/xml//g'     a.txt     //将所有的xml都删除（替换为空串）
                            sed 's#/bin/bash#/sbin/sh#' a.txt  //将/bin/bash替换为/sbin/sh
                            sed '4,7s/^/#/'   a.txt         //将第4~7行注释掉（行首加#号）
                            sed 's/^#an/an/'  a.txt         //解除以#an开头的行的注释（去除行首的#号）

                       利用sed完成本例要求的任务

                           1）删除文件中每行的第二个、最后一个字符
                              分两次替换操作，第一次替换掉第2个字符，第二次替换掉最后一个字符：
                            sed 's/.//2 ; s/.$//' nssw.txt 

                           2）将文件中每行的第一个、倒数第1个字符互换
                              每行文本拆分为“第1个字符”、“中间的所有字符”、“倒数第1个字符”三个部分，然后通过替换操作重排顺序为“3-2-1”：
                            sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt

                           3）删除文件中所有的数字
                              因原文件内没有数字，行首也没有空格，这里稍作做一点处理，生成一个新测试文件：
                            sed 's/[0-9]//' nssw.txt
                     
                              删除所有数字、行首空格的操作如下：
                            sed -r 's/[0-9]//g;s/^( )+//' nssw2.txt

                          4）为文件中每个大写字母添加括号
                             使用“（）”可实现保留功能，所以可参考下列操作解决：
                            sed -r 's/([A-Z])/[\1]/g' nssw.txt

                sed多行文本处理:


                            sed [选项] '条件指令' 文件..
                            sed工具的多行文本处理操作：
                            i： 在指定的行之前插入文本
                            a：在指定的行之后追加文本
                            c：替换指定的行

                            基本语法格式案例：
 
                           sed  '2a XX'   a.txt            //在第二行后面，追加XX
                           sed  '2i XX'   a.txt            //在第二行前面，插入XX
                           sed  '2c XX'   a.txt            //将第二行替换为XX

                               1）使用sed修改主机名配置所在行的内容（c整行替换）
                           sed  '1c mysvr.tarena.com' /etc/hostname 

                               2）使用sed修改hosts文件，添加两行新纪录（a追加）
                           sed  -i  '$a 192.168.4.5  svr5.tarena.com svr5'  /etc/hosts


                         
                     总结知识点：
                          #sed [选项] '条件指令' 文件
                                 选项:
                         -n 屏蔽默认输出
                         -r 支持扩展正则
                         -i 修改源文件
                                 条件：
                                 行号 4 4,5 4~2 4,+10
                                 /正则/
                                 指令：
                          p 打印
                          d 删除
                          s 替换s/旧/新/g
                          a 追加
                          i 插入
                          c 替换行
 
                    sed命令

                              a\ 在当前行下面插入文本。
                              i\ 在当前行上面插入文本。
                              c\ 把选定的行改为新的文本。
                              d 删除 ，删除选择的行。
                              D 删除模板块的第一行。
                              s 替换指定字符
                              h 拷贝模板块的内容到内存中的缓冲区。
                              H 追加模板块的内容到内存中的缓冲区。
                              g 获得内存缓冲区的内容，并替代当前模板块中的文本。                                                
                              G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
                              l 列表不能打印字符的清单。
                              n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
                              N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
                              p 打印模板块的行。
                              P(大写) 打印模板块的第一行。
                              q 退出Sed。
                              b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
                              r file 从file中读行。
                              t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
                              T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
                              w file 写并追加模板块到file末尾。  
                              W file 写并追加模板块的第一行到file末尾。  
                                      ! 表示后面的命令对所有没有被选定的行发生作用。  
                                      = 打印当前行号码。  
                                      # 把注释扩展到下一个换行符以前。  
                     
                   sed替换标记

                             g 表示行内全面替换。  
                             p 表示打印行。  
                             w 表示把行写入一个文件。  
                             x 表示互换模板块中的文本和缓冲区中的文本。  
                             y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
                                     \1 子串匹配标记
                                     & 已匹配字符串标记

                   sed元字符集

                                    ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。 
                                    $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
                                    . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
                                    * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
                                    [] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  
                                    [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
                                    \(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
                                    & 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
                                    \< 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
                                    \> 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
                            x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
                            x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
                            x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。




	模板块=pattern space
        缓存块=hold space
                     先讲n/N的区别
                           ywlscpl大牛这么比喻：
                                   如果sed的模式空间对应awk的$0
                           N相当于awk的{v=$0;next;$0=v"\n"$0}
                           n相当于awk的next

                     用shell来比喻的话
                           N是:  echo 下一行内容>>模式空间
                           n是:  echo 下一行内容>模式空间
                    
                           seq 4 | sed ‘n;d’
                                   1
                                   3

                           pattern space先读入1，然后执行到n，把下一行2读入pattern space中并覆盖原本的1。
                                   然后pattern space中的内容（2）被删除（d操作），所以打印出1\n3。

                           seq 5 | sed ‘n;d’          你知道它输出什么吗？ 
                                   1
                                   3
                                   5
                                   你猜对了吗？

                           seq 4 | sed ‘N;d’

                                   什么都没输出？对，你没看错。pattern space先读入1，然后执行到N，把下一行添加到当前的pattern space中，pattern space内容为（1\n2，对否？），
                                   然后执行d操作被删除。接下去读入3（系统读入总是覆盖原有内容），执行N，pattern space 内容变为（3\n4），然后再被删除。

                           seq 7 | sed ‘N;d’       #你知道它输出什么吗？
                                   7
                                   你猜对了吗？ 简单吧?

                           -n 参数指不自动打印pattern space内容，有的人对它理解不够导致测试n/N区别时被搞的越来越糊涂了。
                           seq 4 | sed –n ‘n’
                           seq 4 | sed –n ‘N’ 

                                  上述两个不输出任何信息，不用说了吧！ ：）

                           seq 4 | sed –n ‘n;p’      
                                   2
                                   4
 
                                   这个能理解么？ 参数p指打印pattern space的内容。

                           seq 4 | sed –n ‘N;p’
                                   1 
                                   2
                                   3
                                   4 
                                   这个呢？也懂！对吧。
                           
                           seq 5 | sed –n ‘N;p’
                                   1
                                   2
                                   3
                                   4 
                                   这个呢？也懂吧？再看看这个
                     
                           seq 5 | sed –n ‘n;p’
                                   自己实验去。：）自己动手才记得牢。


                         接下说x
                           sed有hold space和pattern space，x的意思就是将hold space和pattern space的内容交换。
                                   看懂上面n/N区别的你，看懂下面的实验就很轻松了。

                           seq 4 | sed –n ‘x;p’
                             
                                   1 
                                   2
                                   3
                                    第一行空白？没错，因为pattern space读入1时，hold space还是空的，两者一交换，pattern space不就成空了吗？
                                    而hold space持有1，对否？然后，hold space 和 pattern space再交换内容，此时pattern space得到1，hold space得到2，
                                    打印pattern space不就打印出1了。序列最后是4，但只能打印出3，也能理解了吧。因为4在hold space里了。
       
                                    在sedline中有一题：在每个含有字符串regex的行上插入一行空白行。
                            seq 4 | sed ‘/3/{x;p;x;}’  
                                    1
                                    2

                                    3
                                    4
                                    看懂了没？在找到regex的那一行时，pattern space的内容不就是这匹配的整行数据么，跟hold space交换后，pattern space不就为空了，
                                    然后执行p操作输出空行，然后再跟hold space交换内容，这时pattern space不就又拿到其原本的数据了吗？
                                    你有可能会问，括号里为什么要有p操作啊，命令啥时自动输出pattern space内容啊？
                                    额，这个你可是试试把p去掉后结果是怎么样的啊，看下结果你就懂啦。或者是你看如下操作
                            seq 4 | sed ‘/3/{x;p;x;d}’
                                    1
                                    2

                                    4
                                    我们的操作都是括号里面，所以输出删除等操作由你自己决定啦。这样解释x操作能懂了吧？

                                    接下去讲h/H，分别为复制（覆盖）/添加pattern space到hold space。
                                    这个没什么例子能单独举的呢。不行？必须要例子。。额。好吧，看下面。
                            seq 4 | sed ‘x’       #还记得结果吗？跟sed –n ‘x;p’一样的哦。

                                    1
                                    2
                                    3
                            seq 4 | sed ‘h;x’
                                    1
                                    2
                                    3
                                    4
                                    很容易懂吧？h操作把pattern space内容复制到hold space去了。x操作交换它俩的内容，两者一模一样，交换个啥啊。：）
                            seq 4 | sed ‘x;h’




                                    额，我浪费版面？额，我哭。是输出四个空行啦。x操作把空的hold space和pattern space交换，
                                    然后空的pattern space又把它自己复制给hold space，这样hold space和pattern space永远都成空了。╮(╯▽╰)╭，解释清楚了没？

                               •接下去讲g/G，分别为复制（覆盖）/添加hold space到pattern space。
                                    假如你想要把能匹配regex的这一行变成空行，可以考虑用g哦。假如你想要把能匹配regex的这一行下一行再添加一空行，可以考虑用G哦。
                            seq 4 | sed ‘/3/g’
                                    1
                                    2

                                    4 
                                    原理？额，不用多说了吧。想不通？你再想想。额，很简单。我还是smallpboy啊，大鸟飞过就好了嘛。

                      sed其他：
                                 1、        wc –l功能：
                                 sed –n ‘$=’ filename     
                                          “=”操作指打印行号，可以执行sed –n ‘=’ filename仔细体会下它和-n之间的关系。“$”指最后一行。
                                 2、        tac 功能
                                 sed ‘1!G;h;$!d’ filename
                                 G和h操作还记得么？忘了就去前面看看吧。这里难懂的还有“1!”和“$!”，其实它俩很简单，
                                          在其他语言中就是“!1”和“!$”这样，即非第一行，非最后一行的意思。这块能懂吗？类似的，
                                          删除空行使用 sed ‘/^$/d’，那删除非空行呢？删除非空行？对，使用sed ‘/^$/!d’就好了嘛。
                                          好了，如果了解了“1!”和“$!”的意思了，现在可以开始分解上述命令了。
                                 seq 3 | sed ‘1!;G’
                                           1
                                           2

                                           3

                                         “1”下面没有空行是否在你预料之内呢？G操作在第二行（也就是第二次操作）之后才起作用。
                                 seq 3 | sed ‘1!;G;h’
                                           这个就复杂了，h操作将pattern space内容复制到hold space，第一次读入1时，G操作被禁止，pattern space内容为1吧。
                                           然后h操作将这个1复制过去了。第二次读入2时，G操作将hold space内容添加到pattern space（结果为2\n1，能跟上我的思路不？），
                                           然后h操作将hold space的内容从第一次结束时的1，更新为2\n1，也就是第二次结束的结果。
                                           这样，当读入3时（也即是第三次），G操作将pattern space变成了3\n2\n1。是否？：）所以上述命令输出如下：
                                            1
                                  2\n1
                                  3\n2\n1
                                            能看懂么？当然，终端上可不会显示“\n”字符的哈。最后，指保留最后一行，大功告成：
                                  seq 3 | sed ‘1!;G;h;$!d’
                                            3
                                            2
                                            1
                                            这样，全懂了吧？ ╮(╯▽╰)╭，说的好纠结，好婆妈啊。^)^


                                  3、        rev功能
 
                                  sed ‘/\n/!G;s/\(.\)\(.*\n\)/&\2\1;//D;s/.//;’
                                            实话说，这个命令确实，我也半懂不懂的，确实很复杂啊。勉强说下：
                                   “/\n/!G;”这个能理解不？在stdin中没有找到\n，就主动添上\n。
                                   “s/\(.\)\(.*\n\)/&\2\1;”中\(.\)先匹配一个字符，再匹配剩下所有字符。“&”指整个pattern space，\2和\1想必你也知道是什么东东。
                                   “//D”指删除pattern space第一行，space非空就循环执行。“s/.//”就不解释了。假设我们有文件：
                                   cat file
                                             123
                                   file文件中“123\n”执行s/\(.\)\(.*\n\)/&\2\1;
                                   cat file | sed ‘/\n/!G;s/\(.\)\(.*\n\)/&\2\1;’
                                             123
                                             23
                                             1
                                             上面可能读懂？“123\n”分别被匹配为\1（1）和\2（23\n），所以&\2\1的结果为123\n23\n1。
                                   cat file | sed ‘/\n/!G;s/\(.\)\(.*\n\)/&\2\1;//D’
                                              这个复杂了，咋们严肃点一步一步来说。上面说到第一次执行s….后，结果（谁的结果？这个还要提示么？pattern space啊。）为123\n23\n1，
                                              然后要执行//D命令了，结果为23\n1。
                                              然后到开头继续执行/\n/!G;，pattern space（旧的）不变，
                                              然后执行s….后，新的pattern space为23\n3\n21（\1为2，\2为3\n,&为23\n），
                                              然后执行//D,结果为3\n21。
                                              再执行/\n/!G;，pattern space（下一操作s….会产生新的pattern space把这个给覆盖）不变，
                                              执行s….，结果变为3\n\n321（\1为3，\2为\n，&为3\n），再执行//D操作，结果为\n321，此结果还不为空。
                                              继续执行/\n/!G;，pattern space不变，
                                              然后执行s….，发现匹配不了，此时pattern space没有被重新赋值。
                                              执行//D操作后，结果为321。然后，然后，就发现错了。。。。。
                                   cat file | sed ‘/\n/!G;s/\(.\)\(.*\n\)/&\2\1;P;//D’  
                                             123
                                             23
                                             3

                                             321






                         使用awk提取文本

                            awk文本过滤的基本用法

                                     1）基本操作方法
                                            格式：awk [选项] '[条件]{指令}' 文件
                                            其中，print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。
                                  Awk过滤数据时支持仅打印某一列，如第2列、第5列等。
                                            处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。

                                        直接过滤文件内容：
                                   cat test.txt 
                                   hello the world
                                   welcome to beijing
                                   awk '{print $1,$3}' test.txt        //打印文档第1列和第3列
                                   hello world
                                   welcome beijing

                                        结合管道过滤命令输出：
                                   df -h | awk '{print $4}'        //打印磁盘的剩余空间

                                  2）选项 -F 可指定分隔符

                                       输出passwd文件中以分号分隔的第1、7个字段，显示的不同字段之间以逗号隔开，操作如下：
                                  awk -F: '{print $1,$7}' /etc/passwd
                                    root /bin/bash
                                    bin /sbin/nologin
 

                              awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段：
                                 awk -F [:/] '{print $1,$10}' /etc/passwd

                                    root bash
                                    bin nologin

                         awk常用内置变量：

                                              $0 文本当前行的全部内容
                                              $1	文本的第1列
                                              $2	文件的第2列
                                              $3	文件的第3列，依此类推
                                    NR	文件当前行的行号
                                    NF	文件当前行的列数（有几列）
                                    length（）  计算字幅长度
                                      输出每次处理行的行号，以及当前行以“:”分隔的字段个数（有几列）：
                                    awk -F: '{print NR,NF}' passwd.txt
                                               1 7
                                               2 7
                                               3 7
                                               .. ..

                         2）awk的print指令不仅可以打印变量，还可以打印常量
                                    awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
                                    root 的解释器: /bin/bash
                                    bin 的解释器: /sbin/nologin
                                                … …
                                1，利用awk提取本机的网络流量、根分区剩余容量、获取远程失败的IP地址

                         RX为接收的数据量，TX为发送的数据量。packets以数据包的数量为单位，bytes以字节为单位：
                                    ifconfig eth0 | awk '/RX p/{print $5}'    //过滤接收数据的流量
                                               319663094
                                    ifconfig eth0 | awk '/TX p/{print $5}'     //过滤发送数据的流量
                                               40791683

                                2，提取根分区剩余容量
                                    分步实现的思路及操作参考如下——
                                    通过df命令查看根分区的使用情况，其中包括剩余容量：

                            df -h | awk '/\/$/{print $4}'
                            11G
                       
                               3，根据/var/log/secure日志文件，过滤远程连接密码失败的IP地址
                            awk '/Failed/{print $11}' /var/log/secure
                                    192.168.2.254
                                    192.168.2.100
                                    ... ...

                          格式化输出/etc/passwd文件

                        1）awk处理的时机
                            awk会逐行处理文本，支持在处理第一行之前做一些准备工作，以及在处理完最后一行之后做一些总结性质的工作。在命令格式上分别体现如下：
                            awk  [选项]  '[条件]{指令}'  文件
                            awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件
                            BEGIN{ }	行前处理，读取文件内容前执行，指令执行1次
                                    { }	逐行处理，读取文件过程中执行，指令执行n次
                            END{ }	行后处理，读取文件结束后执行，指令执行1次

                                    只做预处理的时候，可以没有操作文件，比如：
                            awk 'BEGIN{A=24;print A*2}'
                            awk 'BEGIN{print x+1}'           #x可以不定义，直接用，默认值位0
                            awk 'BEGIN{print 3.2+3.5}'

               统计系统中使用bash作为登录Shell的用户总个数：

                            awk 'BEGIN{x=0}/bash$/{x++} END{print x}' /etc/passwd
                                    29
   
                               2）格式化输出/etc/passwd文件
                                   要求: 格式化输出passwd文件内容时，要求第一行为列表标题，中间打印用户的名称、UID、家目录信息，最后一行提示一共已处理文本的总行数，如图-1所示。


                                   输出信息时，可以使用“\t”显示Tab制表位：
                            awk -F: 'BEGIN{print "User\tUID\tHome"} \
                                {print $1 "\t"  $3  "\t"  $6}     \
                             END{print "Total",NR,"lines."}' /etc/passwd
                             User    UID     Home
                             root    0       /root
                             bin     1       /bin
                                     .. ..
                            Total 67 lines.
         
                    认识awk处理条件的设置:

                               1）使用正则设置条件
                                    输出其中以bash结尾的完整记录：
                            awk -F: '/bash$/{print}' /etc/passwd
                            root:x:0:0:root:/root:/bin/bash

                                    输出包含root的行数据：
                            awk -F: '/root/' /etc/passwd
                                    输出root或adm账户的用户名和UID信息：
                            awk -F: '/^(root|adm)/{print $1,$3}' /etc/passwd
                            root 0
                            adm 3

                                    输出账户名称包含root的基本信息（第1列包含root）：
                            awk -F: '$1~/root/' /etc/passwd
                                    输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息：
                            awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd
                            root /bin/bash
                            sync /bin/sync
                            shutdown /sbin/shutdown
     
                              2）使用数值/字符串比较设置条件
                                    比较符号：==(等于) !=（不等于） >（大于）
                                    >=（大于等于） <（小于） <=（小于等于）
                                    输出第3行（行号NR等于3）的用户记录：
                            awk -F: 'NR==3{print}' /etc/passwd
                                    输出账户UID大于等于1000的账户名称和UID信息：
                            awk -F: '$3>=1000{print $1,$3}' /etc/passwd
                            tom 1000
                            jerry 1001

                                    输出账户UID小于10的账户名称和UID信息：
                            awk -F: '$3<10{print $1,$3}' /etc/passwd
                            root 0

                                    输出用户名为“root”的行：
                            awk -F: '$1=="root"' /etc/passwd
                            root:x:0:0:root:/root:/bin/bash

                             3）逻辑测试条件
                                    输出账户UID大于10并且小于20的账户信息：
                            awk -F: '$3>10 && $3<20' /etc/passwd
                            operator:x:11:0:operator:/root:/sbin/nologin
                            games:x:12:100:games:/usr/games:/sbin/nologin
                            ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin

                                    输出账户UID大于1000或者账户UID小于10的账户信息：
                            awk -F: '$3>1000 || $3<10' /etc/passwd
                            root:x:0:0:root:/root:/bin/bash
                                    ... ...
                            varnish:x:1001:1001::/home/varnish:/sbin/nologin
                            nginx:x:1002:1002::/home/nginx:/sbin/nologin

                             4）数学运算
                            awk 'BEGIN{x++;print x}'
                                    1
                            seq  200 | awk  '$1%3==0'       //找200以内3的倍数
                                    … …

                       完成任务要求的awk过滤操作

                            1）列出UID间于1~1000的用户详细信息：

                         awk -F: '$3>=1 && $3<=1000' /etc/passwd

                            2）输出/etc/hosts映射文件内以127或者192开头的记录：

                         awk  '/^(127|192)/' /etc/hosts
                         127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
                         192.168.4.5  svr5.tarena.com svr5

                            3）列出100以内整数中7的倍数或是含7的数：
                         seq 100 | awk '$1%7==0||$1~/7/'
                                 7
                                 14
                                 17
                                 ...

                     找到使用bash作登录Shell的本地用户
                     列出这些用户的shadow密码记录，如图-2所示


                        #/bin/bash
                        A=$(awk -F:  '/bash$/{print $1}' /etc/passwd)        ## 提取符合条件的账号记录
                        for i in $A 
                        do
                             grep $i /etc/shadow | awk -F: '{print $1,"-->",$2}'                
                        done

             awk流程控制:

                if分支结构（单分支、双分支、多分支）


                awk过滤中的if分支结构:

                        1）单分支
                           统计/etc/passwd文件中UID小于或等于1000的用户个数：
                       awk -F: '{if($3<=1000){i++}}END{print i}' /etc/passwd
                              39
                           统计/etc/passwd文件中UID大于1000的用户个数：
                       awk -F: '{if($3>1000){i++}}END{print i}' /etc/passwd
                              8
                           统计/etc/passwd文件中登录Shell是“/bin/bash”的用户个数：
                       awk -F: '{if($7~/bash$/){i++}}END{print i}'  /etc/passwd
                              29
                       2）双分支
                           分别统计/etc/passwd文件中UID小于或等于1000、UID大于1000的用户个数：
                       awk -F: '{if($3<=1000){i++}else{j++}}END{print i,j}' /etc/passwd
                              39 8
                           分别统计/etc/passwd文件中登录Shell是“/bin/bash”、 登录Shell不是“/bin/bash”的用户个数：
                       awk -F: '{if($7~/bash$/){i++}else{j++}} END{print i,j}' /etc/passwd
                              29 38
               awk数组

                       1）数组的语法格式
                            数组是一个可以存储多个值的变量，具体使用的格式如下：
                            定义数组的格式：数组名[下标]=元素值
                            调用数组的格式：数组名[下标]
                            遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。
                      awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'
                             88 11
                      awk 'BEGIN{a++;print a}'
                             1
                      awk 'BEGIN{a0++;print a0}'
                             1
                      awk 'BEGIN{a[0]++;print a[0]}'
                             1
                      awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'
                             0 0
                             1 11
                             2 22
                     注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：

                    awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'
                          11
             awk扩展应用:
 

                          本案例要求使用awk工具完成下列两个任务：
                          分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名



                     分步测试、验证效果如下所述。

                    awk  '{ip[$1]++} END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log | sort -nr
                          17 192.168.4.5
                          13 192.168.4.110
                          4 127.0.0.1
                          .. ..

             awk next语句使用：
                          在循环逐行匹配，如果遇到next,就会跳过当前行，直接忽略下面语句。而进行下一行匹配。

                    text.txt 内容是：

                     a
                     b
                     c
                     d
                     e
 
 

                   awk 'NR%2==1{next}{print NR,$0;}' text.txt     
                      2 b
                      4 d

                    当记录行号除以2余 1，就跳过当前行。下面的print NR,$0也不会执行。 下一行开始，程序有开始判断NR%2 值。这个时候记录行号是：2 ，就会执行下面语句块：'print NR,$0'

 

 

            awk next使用实例：

                           要求：

                         文件：text.txt 格式：
                    web01[192.168.2.100]

                    httpd            ok
                    tomcat               ok
                    sendmail               ok
                    web02[192.168.2.101]
                    httpd            ok
                    postfix               ok
                    web03[192.168.2.102]
                    mysqld            ok
                    httpd               ok

 

                需要通过awk将输出格式变成：

                   web01[192.168.2.100]:   httpd            ok
                   web01[192.168.2.100]:   tomcat               ok
                   web01[192.168.2.100]:   sendmail               ok
                   web02[192.168.2.101]:   httpd            ok
                   web02[192.168.2.101]:   postfix               ok
                   web03[192.168.2.102]:   mysqld            ok
                   web03[192.168.2.102]:   httpd               ok

 

                分析：

                  分析发现需要将包含有“web”行进行跳过，然后需要将内容与下面行合并为一行。

                  awk '/^web/{T=$0;next;}{print T":\t"$0;}' test.txt

                  web01[192.168.2.100]:   httpd            ok
                  web01[192.168.2.100]:   tomcat               ok
                  web01[192.168.2.100]:   sendmail               ok
                  web02[192.168.2.101]:   httpd            ok
                  web02[192.168.2.101]:   postfix               ok
                  web03[192.168.2.102]:   mysqld            ok
                  web03[192.168.2.102]:   httpd               ok
#使用 stty ‐echo 关闭 shell 的回显功能 
#使用 stty  echo 打开 shell 的回显功能 


#!/bin/bash 
#Author:丁丁历险(Jacob) 
#使用 netstat ‐atn 可以查看本机所有连接的状态,‐a 查看所有,‐t 仅显示 tcp 连接的信息,‐n 数字格式显示
# Local Address(第四列是本机的 IP 和端口信息) 
#Foreign Address(第五列是远程主机的 IP 和端口信息) 
#使用 awk 命令仅显示第 5 列数据,再显示第 1 列 IP 地址的信息 
#sort 可以按数字大小排序,最后使用 uniq 将多余重复的删除,并统计重复的次数 
netstat ‐atn  |  awk  '{print $5}'  | awk  '{print $1}' | sort ‐nr  |  uniq ‐c 

检测 MySQL 数据库连接数量
`mysqladmin  ‐u  "$user"  ‐p  "$passwd"   status |  awk '{print $4}'` 

根据 md5 校验码,检测文件是否被修改
#!/bin/bash 
#Author:丁丁历险(Jacob) 
#本示例脚本检测的是/etc 目录下所有的 conf 结尾的文件,根据实际情况,您可以修改为其他目录或文件 
#本脚本在目标数据没有被修改时执行一次,当怀疑数据被人篡改,再执行一次 
#将两次执行的结果做对比,MD5 码发生改变的文件,就是被人篡改的文件 
for  i  in  $(ls /etc/*.conf) 
do 
  md5sum "$i" >> /var/log/conf_file.log 
done 


备份 MySQL 的 shell 脚本(mysqldump 版本)
#!/bin/bash 
#Author:丁丁历险(Jacob) 
#定义变量 user(数据库用户名),passwd(数据库密码),date(备份的时间标签) 
#dbname(需要备份的数据库名称,根据实际需求需要修改该变量的值,默认备份 mysql 数据库) 
 
user=root 
passwd=123456 
dbname=mysql 
date=$(date +%Y%m%d) 
 
#测试备份目录是否存在,不存在则自动创建该目录 
[  ! ‐d  /mysqlbackup  ] &&  mkdir  /mysqlbackup 
#使用 mysqldump 命令备份数据库 
mysqldump ‐u"$user"  ‐p"$passwd" "$dbname" > /mysqlbackup/"$dbname"‐${date}.sql 


将文件中所有的小写字母转换为大写字母
#!/bin/bash 
#$1 是位置参数,是你需要转换大小写字母的文件名称 
#执行脚本,给定一个文件名作为参数,脚本就会将该文件中所有的小写字母转换为大写字母 
tr  "[a‐z]"  "[A‐Z]"  < $1 

#!/bin/bash 
#‐t 指定 SSH 密钥的算法为 RSA 算法;‐N 设置密钥的密码为空;‐f 指定生成的密钥文件存放在哪里 
rm  ‐rf  ~/.ssh/{known_hosts,id_rsa*} 
ssh‐keygen ‐t RSA ‐N '' ‐f ~/.ssh/id_rsa 


#!/bin/bash 
#Author:丁丁历险(Jacob) 
#设置变量,url 为你需要检测的目标网站的网址(IP 或域名) 
url=http://192.168.4.5/index.html 
 
#定义函数 check_http: 
#使用 curl 命令检查 http 服务器的状态 
#‐m 设置 curl 不管访问成功或失败,最大消耗的时间为 5 秒,5 秒连接服务为相应则视为无法连接 
#‐s 设置静默连接,不显示连接时的连接速度、时间消耗等信息 
#‐o 将 curl 下载的页面内容导出到/dev/null(默认会在屏幕显示页面内容) 
#‐w 设置 curl 命令需要显示的内容%{http_code},指定 curl 返回服务器的状态码 
check_http(){ 
status_code=$(curl ‐m 5 ‐s ‐o /dev/null ‐w %{http_code} $url) 
} 
 
while : 
do 
  check_http 
  date=$(date +%Y%m%d‐%H:%M:%S)  
#生成报警邮件的内容 
  echo "当前时间为:$date 
  $url 服务器异常,状态码为${status_code}. 
  请尽快排查异常." > /tmp/http$$.pid 
  
#指定测试服务器状态的函数,并根据返回码决定是发送邮件报警还是将正常信息写入日志 
  if [ $status_code ‐ne 200 ];then 
  
mail ‐s Warning root < /tmp/http$$.pid 
  else 
  
echo "$url 连接正常" >> /var/log/http.log 
  fi 
  sleep 5 
done 

显示 CPU 厂商信息
#!/bin/bash 
awk '/vendor_id/{print $3}' /proc/cpuinfo |uniq


50. 删除某个目录下大小为 0 的文件
#!/bin/bash 
#/var/www/html 为测试目录,脚本会清空该目录下所有 0 字节的文件 
dir="/var/www/html" 
find $dir  ‐type f  ‐size  0  ‐exec  rm   ‐rf {} \; 
 
51. 查找 Linux 系统中的僵尸进程
#!/bin/bash 
#awk 判断 ps 命令输出的第 8 列为 Z 是,显示该进程的 PID 和进程命令 
ps aux |awk '{if($8 == "Z"){print $2,$11}}' 

生成随机密码(urandom 版本)
#!/bin/bash 
#Author:丁丁历险(Jacob) 
#/dev/urandom 文件是 Linux 内置的随机设备文件 
#cat /dev/urandom 可以看看里面的内容,ctrl+c 退出查看 
#查看该文件内容后,发现内容有些太随机,包括很多特殊符号,我们需要的密码不希望使用这些符号 
#tr ‐dc '_A‐Za‐z0‐9'  </dev/urandom    
#该命令可以将随机文件中其他的字符删除,仅保留大小写字母,数字,下划线,但是内容还是太多 
#我们可以继续将优化好的内容通过管道传递给 head 命令,在大量数据中仅显示头 10 个字节 
#注意 A 前面有个下划线 
tr ‐dc '_A‐Za‐z0‐9'  </dev/urandom  | head  ‐c  10 


55. 生成随机密码(UUID 版本,16 进制密码)
#!/bin/bash 
uuidgen 
 
56. 生成随机密码(进程 ID 版本,数字密码)
#!/bin/bash



59. Shell 脚本的 fork 炸弹
#!/bin/bash 
#快速消耗计算机资源,致使计算机死机 
#定义函数名为.(点), 函数中递归调用自己并放入后台执行 
.() { .|.& };. 


#!/bin/bash 
#Author:丁丁历险(Jacob) 
ip  a  s  |awk  'BEGIN{print  " 本 机 MAC 地 址 信 息 如 下 :"}/^[0‐9]/{print 
$2;getline;if($0~/link\/ether/){print $2}}' |grep ‐v lo: 
 
#awk 读取 ip 命令的输出,输出结果中如果有以数字开始的行,先显示该行的地 2 列(网卡名称), 
#接着使用 getline 再读取它的下一行数据,判断是否包含 link/ether 
#如果保护该关键词,就显示该行的第 2 列(MAC 地址) 
#lo 回环设备没有 MAC,因此将其屏蔽,不显示 


#!/bin/bash 
#Author:丁丁历险(Jacob) 
#往/etc/security/limits.conf 文件的末尾追加两行配置参数,修改最大打开文件数量为 65536 
cat >> /etc/security/limits.conf <<EOF 
* soft nofile  65536 
* hard nofile  65536 
EOF

73. 统计/etc/passwd 中 root 出现的次数
#!/bin/bash 
#每读取一行文件内容,即从第 1 列循环到最后 1 列,依次判断是否包含 root 关键词,如果包含则 x++ 
awk ‐F: '{i=1;while(i<=NF){if($i~/root/){x++};i++}} END{print "root 出现次数为"x}' /etc/passwd





74. 统计 Linux 进程相关数量信息
#!/bin/bash 
#Author:丁丁历险(Jacob) 
running=0 
sleeping=0 
stoped=0 
zombie=0 
#在 proc 目录下所有以数字开始的都是当前计算机正在运行的进程的进程 PID 
#每个 PID 编号的目录下记录有该进程相关的信息 
for  pid  in  /proc/[1‐9]* 
do 
  procs=$[procs+1] 
  stat=$(awk '{print $3}' $pid/stat) 
#每个 pid 目录下都有一个 stat 文件,该文件的第 3 列是该进程的状态信息 
  case $stat in 
  R) 
  
running=$[running+1];; 
  T) 
  
stoped=$[stoped+1];; 
  S) 
  
sleeping=$[sleeping+1];; 
  Z) 
  
zombie=$[zombie+1];; 
  esac 
done 
echo "进程统计信息如下" 
echo "总进程数量为:$procs" 
echo "Running 进程数为:$running" 
echo "Stoped 进程数为:$stoped" 
echo "Sleeping 进程数为:$sleeping" 
echo "Zombie 进程数为:$zombie" 

76. 判断用户输入的数据类型(字母、数字或其他)
#!/bin/bash 
#Author:丁丁历险(Jacob) 
read ‐p "请输入一个字符:" KEY 
case "$KEY" in 
[a‐z]|[A‐Z]) 
echo "字母" ;; 
[0‐9]) 
echo "数字" ;; 
*) 
echo "空格、功能键或其他控制字符" 
esac 



80. 显示本机 Linux 系统上所有开放的端口列表
#!/bin/bash 
#Author:丁丁历险(Jacob) 
#从端口列表中观测有没有没用的端口,有的话可以将该端口对应的服务关闭,防止意外的攻击可能性 
ss ‐nutlp |awk '{print $1,$5}' |awk ‐F"[: ]" '{print "协议:"$1,"端口号:"$NF}' |grep "[0‐9]" 
|uniq 

87. Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本
#!/bin/bash 
#Author:丁丁历险(Jacob) 
#使用 trap 命令可以拦截用户通过键盘或 kill 命令发送过来的信号 
#使用 kill ‐l 可以查看 Linux 系统中所有的信号列表,其中 2 代表 Ctrl+C 
#trap 当发现有用户 ctrl+C 希望终端脚本时,就执行 echo "暂停 10s";sleep 10 这两条命令 
#另外用户使用命令:[ kill ‐2 脚本的 PID ] 也可以中断脚本和 Ctrl+C 一样的效果,都会被 trap 拦截 
trap 'echo "暂停 10s";sleep 10'  2 
while : 
do 
    echo "go go go" 
done 






